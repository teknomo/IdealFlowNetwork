

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="./">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Ideal Flow Package &mdash; Ideal Flow Network (IFN) 1.5 documentation</title>
      <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=80d5e7a1" />
      <link rel="stylesheet" type="text/css" href="_static/css/theme.css?v=e59714d7" />

  
      <script src="_static/jquery.js?v=5d32c60e"></script>
      <script src="_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="_static/documentation_options.js?v=aaadad1f"></script>
      <script src="_static/doctools.js?v=9bcbadda"></script>
      <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="IdealFlow" href="modules.html" />
    <link rel="prev" title="Unit Tests" href="unit_tests.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="index.html" class="icon icon-home">
            Ideal Flow Network (IFN)
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="overview.html">Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="data_structure.html">Data Structure</a></li>
<li class="toctree-l1"><a class="reference internal" href="unit_tests.html">Unit Tests</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Ideal Flow Package</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#module-IdealFlow">Module contents</a></li>
<li class="toctree-l2"><a class="reference internal" href="#submodules">Submodules</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-IdealFlow.Network">IdealFlow.Network module</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#ideal-flow-network">Ideal Flow Network</a></li>
<li class="toctree-l3"><a class="reference internal" href="#IdealFlow.Network.IFN"><code class="docutils literal notranslate"><span class="pre">IFN</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="#IdealFlow.Network.IFN.abs_diff_capacity_flow"><code class="docutils literal notranslate"><span class="pre">IFN.abs_diff_capacity_flow()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#IdealFlow.Network.IFN.add_first_link"><code class="docutils literal notranslate"><span class="pre">IFN.add_first_link()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#IdealFlow.Network.IFN.add_last_link"><code class="docutils literal notranslate"><span class="pre">IFN.add_last_link()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#IdealFlow.Network.IFN.add_link"><code class="docutils literal notranslate"><span class="pre">IFN.add_link()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#IdealFlow.Network.IFN.add_node"><code class="docutils literal notranslate"><span class="pre">IFN.add_node()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#IdealFlow.Network.IFN.add_random_ones"><code class="docutils literal notranslate"><span class="pre">IFN.add_random_ones()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#IdealFlow.Network.IFN.adj_list_to_matrix"><code class="docutils literal notranslate"><span class="pre">IFN.adj_list_to_matrix()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#IdealFlow.Network.IFN.adjacency_to_ideal_flow"><code class="docutils literal notranslate"><span class="pre">IFN.adjacency_to_ideal_flow()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#IdealFlow.Network.IFN.adjacency_to_stochastic"><code class="docutils literal notranslate"><span class="pre">IFN.adjacency_to_stochastic()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#IdealFlow.Network.IFN.all_shortest_path"><code class="docutils literal notranslate"><span class="pre">IFN.all_shortest_path()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#IdealFlow.Network.IFN.alphabet_list"><code class="docutils literal notranslate"><span class="pre">IFN.alphabet_list()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#IdealFlow.Network.IFN.assign"><code class="docutils literal notranslate"><span class="pre">IFN.assign()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#IdealFlow.Network.IFN.assign_adjacency_list"><code class="docutils literal notranslate"><span class="pre">IFN.assign_adjacency_list()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#IdealFlow.Network.IFN.assign_cycle_to_matrix"><code class="docutils literal notranslate"><span class="pre">IFN.assign_cycle_to_matrix()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#IdealFlow.Network.IFN.association_predict_actor_net"><code class="docutils literal notranslate"><span class="pre">IFN.association_predict_actor_net()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#IdealFlow.Network.IFN.association_predict_trajectory"><code class="docutils literal notranslate"><span class="pre">IFN.association_predict_trajectory()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#IdealFlow.Network.IFN.association_train"><code class="docutils literal notranslate"><span class="pre">IFN.association_train()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#IdealFlow.Network.IFN.average_flow"><code class="docutils literal notranslate"><span class="pre">IFN.average_flow</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#IdealFlow.Network.IFN.average_flow_matrix"><code class="docutils literal notranslate"><span class="pre">IFN.average_flow_matrix()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#IdealFlow.Network.IFN.average_node_entropy"><code class="docutils literal notranslate"><span class="pre">IFN.average_node_entropy</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#IdealFlow.Network.IFN.average_node_entropy_matrix"><code class="docutils literal notranslate"><span class="pre">IFN.average_node_entropy_matrix()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#IdealFlow.Network.IFN.average_node_entropy_ratio"><code class="docutils literal notranslate"><span class="pre">IFN.average_node_entropy_ratio</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#IdealFlow.Network.IFN.average_node_entropy_ratio_matrix"><code class="docutils literal notranslate"><span class="pre">IFN.average_node_entropy_ratio_matrix()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#IdealFlow.Network.IFN.backtracking"><code class="docutils literal notranslate"><span class="pre">IFN.backtracking()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#IdealFlow.Network.IFN.backtracking_cycle_limit"><code class="docutils literal notranslate"><span class="pre">IFN.backtracking_cycle_limit()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#IdealFlow.Network.IFN.bfs"><code class="docutils literal notranslate"><span class="pre">IFN.bfs()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#IdealFlow.Network.IFN.bfs_until"><code class="docutils literal notranslate"><span class="pre">IFN.bfs_until()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#IdealFlow.Network.IFN.binarized_matrix"><code class="docutils literal notranslate"><span class="pre">IFN.binarized_matrix()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#IdealFlow.Network.IFN.canonize"><code class="docutils literal notranslate"><span class="pre">IFN.canonize()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#IdealFlow.Network.IFN.canonize_cycle_dict"><code class="docutils literal notranslate"><span class="pre">IFN.canonize_cycle_dict()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#IdealFlow.Network.IFN.canonize_signature"><code class="docutils literal notranslate"><span class="pre">IFN.canonize_signature()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#IdealFlow.Network.IFN.capacity_to_adjacency"><code class="docutils literal notranslate"><span class="pre">IFN.capacity_to_adjacency()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#IdealFlow.Network.IFN.capacity_to_balance_inflow_outflow"><code class="docutils literal notranslate"><span class="pre">IFN.capacity_to_balance_inflow_outflow()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#IdealFlow.Network.IFN.capacity_to_congestion"><code class="docutils literal notranslate"><span class="pre">IFN.capacity_to_congestion()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#IdealFlow.Network.IFN.capacity_to_ideal_flow"><code class="docutils literal notranslate"><span class="pre">IFN.capacity_to_ideal_flow()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#IdealFlow.Network.IFN.capacity_to_stochastic"><code class="docutils literal notranslate"><span class="pre">IFN.capacity_to_stochastic()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#IdealFlow.Network.IFN.cardinal_ifn_signature"><code class="docutils literal notranslate"><span class="pre">IFN.cardinal_ifn_signature()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#IdealFlow.Network.IFN.change_flow_in_cycle"><code class="docutils literal notranslate"><span class="pre">IFN.change_flow_in_cycle()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#IdealFlow.Network.IFN.color_graph"><code class="docutils literal notranslate"><span class="pre">IFN.color_graph()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#IdealFlow.Network.IFN.combinations"><code class="docutils literal notranslate"><span class="pre">IFN.combinations()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#IdealFlow.Network.IFN.complement"><code class="docutils literal notranslate"><span class="pre">IFN.complement()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#IdealFlow.Network.IFN.complete_graph"><code class="docutils literal notranslate"><span class="pre">IFN.complete_graph()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#IdealFlow.Network.IFN.compose"><code class="docutils literal notranslate"><span class="pre">IFN.compose()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#IdealFlow.Network.IFN.congestion"><code class="docutils literal notranslate"><span class="pre">IFN.congestion()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#IdealFlow.Network.IFN.copy_dict"><code class="docutils literal notranslate"><span class="pre">IFN.copy_dict()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#IdealFlow.Network.IFN.cov_flow"><code class="docutils literal notranslate"><span class="pre">IFN.cov_flow</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#IdealFlow.Network.IFN.cov_flow_matrix"><code class="docutils literal notranslate"><span class="pre">IFN.cov_flow_matrix()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#IdealFlow.Network.IFN.create_node_mapping"><code class="docutils literal notranslate"><span class="pre">IFN.create_node_mapping()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#IdealFlow.Network.IFN.cycle_dict_to_signature"><code class="docutils literal notranslate"><span class="pre">IFN.cycle_dict_to_signature()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#IdealFlow.Network.IFN.cycle_length"><code class="docutils literal notranslate"><span class="pre">IFN.cycle_length()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#IdealFlow.Network.IFN.cycle_sum_weight"><code class="docutils literal notranslate"><span class="pre">IFN.cycle_sum_weight()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#IdealFlow.Network.IFN.decimal_to_fraction"><code class="docutils literal notranslate"><span class="pre">IFN.decimal_to_fraction()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#IdealFlow.Network.IFN.decompose"><code class="docutils literal notranslate"><span class="pre">IFN.decompose()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#IdealFlow.Network.IFN.delete_link"><code class="docutils literal notranslate"><span class="pre">IFN.delete_link()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#IdealFlow.Network.IFN.delete_node"><code class="docutils literal notranslate"><span class="pre">IFN.delete_node()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#IdealFlow.Network.IFN.density"><code class="docutils literal notranslate"><span class="pre">IFN.density</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#IdealFlow.Network.IFN.dfs"><code class="docutils literal notranslate"><span class="pre">IFN.dfs()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#IdealFlow.Network.IFN.dfs_adj_list"><code class="docutils literal notranslate"><span class="pre">IFN.dfs_adj_list()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#IdealFlow.Network.IFN.dfs_until"><code class="docutils literal notranslate"><span class="pre">IFN.dfs_until()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#IdealFlow.Network.IFN.diameter"><code class="docutils literal notranslate"><span class="pre">IFN.diameter</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#IdealFlow.Network.IFN.difference"><code class="docutils literal notranslate"><span class="pre">IFN.difference()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#IdealFlow.Network.IFN.duplicate"><code class="docutils literal notranslate"><span class="pre">IFN.duplicate()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#IdealFlow.Network.IFN.equivalent_ifn"><code class="docutils literal notranslate"><span class="pre">IFN.equivalent_ifn()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#IdealFlow.Network.IFN.excel_col_to_num"><code class="docutils literal notranslate"><span class="pre">IFN.excel_col_to_num()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#IdealFlow.Network.IFN.extract_first_k_terms"><code class="docutils literal notranslate"><span class="pre">IFN.extract_first_k_terms()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#IdealFlow.Network.IFN.extract_last_k_terms"><code class="docutils literal notranslate"><span class="pre">IFN.extract_last_k_terms()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#IdealFlow.Network.IFN.find_a_cycle"><code class="docutils literal notranslate"><span class="pre">IFN.find_a_cycle()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#IdealFlow.Network.IFN.find_all_cycles_in_adj_list"><code class="docutils literal notranslate"><span class="pre">IFN.find_all_cycles_in_adj_list()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#IdealFlow.Network.IFN.find_all_cycles_in_matrix"><code class="docutils literal notranslate"><span class="pre">IFN.find_all_cycles_in_matrix()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#IdealFlow.Network.IFN.find_all_paths"><code class="docutils literal notranslate"><span class="pre">IFN.find_all_paths()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#IdealFlow.Network.IFN.find_all_permutation_cycles"><code class="docutils literal notranslate"><span class="pre">IFN.find_all_permutation_cycles()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#IdealFlow.Network.IFN.find_all_walks_in_matrix"><code class="docutils literal notranslate"><span class="pre">IFN.find_all_walks_in_matrix()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#IdealFlow.Network.IFN.find_cardinal_ifn_signature_exhaustive"><code class="docutils literal notranslate"><span class="pre">IFN.find_cardinal_ifn_signature_exhaustive()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#IdealFlow.Network.IFN.find_cycles"><code class="docutils literal notranslate"><span class="pre">IFN.find_cycles()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#IdealFlow.Network.IFN.find_element_in_list"><code class="docutils literal notranslate"><span class="pre">IFN.find_element_in_list()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#IdealFlow.Network.IFN.find_key_in_dict"><code class="docutils literal notranslate"><span class="pre">IFN.find_key_in_dict()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#IdealFlow.Network.IFN.find_path"><code class="docutils literal notranslate"><span class="pre">IFN.find_path()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#IdealFlow.Network.IFN.find_path_cycle_limit"><code class="docutils literal notranslate"><span class="pre">IFN.find_path_cycle_limit()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#IdealFlow.Network.IFN.find_pivot_type"><code class="docutils literal notranslate"><span class="pre">IFN.find_pivot_type()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#IdealFlow.Network.IFN.find_pivots"><code class="docutils literal notranslate"><span class="pre">IFN.find_pivots()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#IdealFlow.Network.IFN.flow_matrix_to_adj_list"><code class="docutils literal notranslate"><span class="pre">IFN.flow_matrix_to_adj_list()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#IdealFlow.Network.IFN.flows_in_cycle"><code class="docutils literal notranslate"><span class="pre">IFN.flows_in_cycle()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#IdealFlow.Network.IFN.form_link_cycle_matrix"><code class="docutils literal notranslate"><span class="pre">IFN.form_link_cycle_matrix()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#IdealFlow.Network.IFN.from_base62"><code class="docutils literal notranslate"><span class="pre">IFN.from_base62()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#IdealFlow.Network.IFN.generate"><code class="docutils literal notranslate"><span class="pre">IFN.generate()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#IdealFlow.Network.IFN.generate_combinations"><code class="docutils literal notranslate"><span class="pre">IFN.generate_combinations()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#IdealFlow.Network.IFN.generate_random_terms"><code class="docutils literal notranslate"><span class="pre">IFN.generate_random_terms()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#IdealFlow.Network.IFN.get_data"><code class="docutils literal notranslate"><span class="pre">IFN.get_data()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#IdealFlow.Network.IFN.get_link_flow"><code class="docutils literal notranslate"><span class="pre">IFN.get_link_flow()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#IdealFlow.Network.IFN.get_links"><code class="docutils literal notranslate"><span class="pre">IFN.get_links</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#IdealFlow.Network.IFN.get_matrix"><code class="docutils literal notranslate"><span class="pre">IFN.get_matrix()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#IdealFlow.Network.IFN.get_path"><code class="docutils literal notranslate"><span class="pre">IFN.get_path()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#IdealFlow.Network.IFN.get_path_entropy"><code class="docutils literal notranslate"><span class="pre">IFN.get_path_entropy()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#IdealFlow.Network.IFN.get_path_probability"><code class="docutils literal notranslate"><span class="pre">IFN.get_path_probability()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#IdealFlow.Network.IFN.global_scaling"><code class="docutils literal notranslate"><span class="pre">IFN.global_scaling()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#IdealFlow.Network.IFN.hadamard_division"><code class="docutils literal notranslate"><span class="pre">IFN.hadamard_division()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#IdealFlow.Network.IFN.has_pivot"><code class="docutils literal notranslate"><span class="pre">IFN.has_pivot()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#IdealFlow.Network.IFN.ideal_flow"><code class="docutils literal notranslate"><span class="pre">IFN.ideal_flow()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#IdealFlow.Network.IFN.ideal_flow_to_stochastic"><code class="docutils literal notranslate"><span class="pre">IFN.ideal_flow_to_stochastic()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#IdealFlow.Network.IFN.identify_unique_nodes"><code class="docutils literal notranslate"><span class="pre">IFN.identify_unique_nodes()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#IdealFlow.Network.IFN.in_degree"><code class="docutils literal notranslate"><span class="pre">IFN.in_degree</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#IdealFlow.Network.IFN.in_neighbors"><code class="docutils literal notranslate"><span class="pre">IFN.in_neighbors()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#IdealFlow.Network.IFN.in_weight"><code class="docutils literal notranslate"><span class="pre">IFN.in_weight</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#IdealFlow.Network.IFN.intersect"><code class="docutils literal notranslate"><span class="pre">IFN.intersect()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#IdealFlow.Network.IFN.inverse_dict"><code class="docutils literal notranslate"><span class="pre">IFN.inverse_dict()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#IdealFlow.Network.IFN.is_acyclic"><code class="docutils literal notranslate"><span class="pre">IFN.is_acyclic</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#IdealFlow.Network.IFN.is_bipartite"><code class="docutils literal notranslate"><span class="pre">IFN.is_bipartite</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#IdealFlow.Network.IFN.is_connected"><code class="docutils literal notranslate"><span class="pre">IFN.is_connected</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#IdealFlow.Network.IFN.is_contain_cycle"><code class="docutils literal notranslate"><span class="pre">IFN.is_contain_cycle</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#IdealFlow.Network.IFN.is_cycle_canonical"><code class="docutils literal notranslate"><span class="pre">IFN.is_cycle_canonical()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#IdealFlow.Network.IFN.is_cycle_has_coef_1"><code class="docutils literal notranslate"><span class="pre">IFN.is_cycle_has_coef_1()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#IdealFlow.Network.IFN.is_edge_in_cycle"><code class="docutils literal notranslate"><span class="pre">IFN.is_edge_in_cycle()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#IdealFlow.Network.IFN.is_equal_network"><code class="docutils literal notranslate"><span class="pre">IFN.is_equal_network()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#IdealFlow.Network.IFN.is_equal_signature"><code class="docutils literal notranslate"><span class="pre">IFN.is_equal_signature()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#IdealFlow.Network.IFN.is_equivalent_ifn"><code class="docutils literal notranslate"><span class="pre">IFN.is_equivalent_ifn()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#IdealFlow.Network.IFN.is_eulerian_cycle"><code class="docutils literal notranslate"><span class="pre">IFN.is_eulerian_cycle</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#IdealFlow.Network.IFN.is_ideal_flow"><code class="docutils literal notranslate"><span class="pre">IFN.is_ideal_flow</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#IdealFlow.Network.IFN.is_ideal_flow_matrix"><code class="docutils literal notranslate"><span class="pre">IFN.is_ideal_flow_matrix()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#IdealFlow.Network.IFN.is_irreducible_matrix"><code class="docutils literal notranslate"><span class="pre">IFN.is_irreducible_matrix()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#IdealFlow.Network.IFN.is_irreducible_signature"><code class="docutils literal notranslate"><span class="pre">IFN.is_irreducible_signature()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#IdealFlow.Network.IFN.is_non_empty_adj_list"><code class="docutils literal notranslate"><span class="pre">IFN.is_non_empty_adj_list()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#IdealFlow.Network.IFN.is_non_negative_matrix"><code class="docutils literal notranslate"><span class="pre">IFN.is_non_negative_matrix()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#IdealFlow.Network.IFN.is_path"><code class="docutils literal notranslate"><span class="pre">IFN.is_path()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#IdealFlow.Network.IFN.is_positive_matrix"><code class="docutils literal notranslate"><span class="pre">IFN.is_positive_matrix()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#IdealFlow.Network.IFN.is_premagic"><code class="docutils literal notranslate"><span class="pre">IFN.is_premagic</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#IdealFlow.Network.IFN.is_premagic_matrix"><code class="docutils literal notranslate"><span class="pre">IFN.is_premagic_matrix()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#IdealFlow.Network.IFN.is_premier_matrix"><code class="docutils literal notranslate"><span class="pre">IFN.is_premier_matrix()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#IdealFlow.Network.IFN.is_premier_signature"><code class="docutils literal notranslate"><span class="pre">IFN.is_premier_signature()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#IdealFlow.Network.IFN.is_reachable"><code class="docutils literal notranslate"><span class="pre">IFN.is_reachable()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#IdealFlow.Network.IFN.is_row_stochastic_matrix"><code class="docutils literal notranslate"><span class="pre">IFN.is_row_stochastic_matrix()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#IdealFlow.Network.IFN.is_square_matrix"><code class="docutils literal notranslate"><span class="pre">IFN.is_square_matrix()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#IdealFlow.Network.IFN.is_strongly_connected"><code class="docutils literal notranslate"><span class="pre">IFN.is_strongly_connected</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#IdealFlow.Network.IFN.is_trajectory_cycle"><code class="docutils literal notranslate"><span class="pre">IFN.is_trajectory_cycle()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#IdealFlow.Network.IFN.is_valid_signature"><code class="docutils literal notranslate"><span class="pre">IFN.is_valid_signature()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#IdealFlow.Network.IFN.kappa"><code class="docutils literal notranslate"><span class="pre">IFN.kappa()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#IdealFlow.Network.IFN.link_combination"><code class="docutils literal notranslate"><span class="pre">IFN.link_combination()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#IdealFlow.Network.IFN.link_cycle_matrix"><code class="docutils literal notranslate"><span class="pre">IFN.link_cycle_matrix()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#IdealFlow.Network.IFN.link_permutation"><code class="docutils literal notranslate"><span class="pre">IFN.link_permutation()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#IdealFlow.Network.IFN.load"><code class="docutils literal notranslate"><span class="pre">IFN.load()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#IdealFlow.Network.IFN.load_adj_list"><code class="docutils literal notranslate"><span class="pre">IFN.load_adj_list()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#IdealFlow.Network.IFN.markov"><code class="docutils literal notranslate"><span class="pre">IFN.markov()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#IdealFlow.Network.IFN.match"><code class="docutils literal notranslate"><span class="pre">IFN.match()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#IdealFlow.Network.IFN.matrix_apply_cycle"><code class="docutils literal notranslate"><span class="pre">IFN.matrix_apply_cycle()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#IdealFlow.Network.IFN.matrix_replace_value"><code class="docutils literal notranslate"><span class="pre">IFN.matrix_replace_value()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#IdealFlow.Network.IFN.matrix_to_adj_list"><code class="docutils literal notranslate"><span class="pre">IFN.matrix_to_adj_list()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#IdealFlow.Network.IFN.max_flow"><code class="docutils literal notranslate"><span class="pre">IFN.max_flow</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#IdealFlow.Network.IFN.max_flow_matrix"><code class="docutils literal notranslate"><span class="pre">IFN.max_flow_matrix()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#IdealFlow.Network.IFN.max_flow_path"><code class="docutils literal notranslate"><span class="pre">IFN.max_flow_path()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#IdealFlow.Network.IFN.max_network_entropy"><code class="docutils literal notranslate"><span class="pre">IFN.max_network_entropy()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#IdealFlow.Network.IFN.merge_adjacency_list"><code class="docutils literal notranslate"><span class="pre">IFN.merge_adjacency_list()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#IdealFlow.Network.IFN.merge_signatures"><code class="docutils literal notranslate"><span class="pre">IFN.merge_signatures()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#IdealFlow.Network.IFN.min_flow"><code class="docutils literal notranslate"><span class="pre">IFN.min_flow</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#IdealFlow.Network.IFN.min_flow_matrix"><code class="docutils literal notranslate"><span class="pre">IFN.min_flow_matrix()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#IdealFlow.Network.IFN.min_flow_path"><code class="docutils literal notranslate"><span class="pre">IFN.min_flow_path()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#IdealFlow.Network.IFN.min_irreducible"><code class="docutils literal notranslate"><span class="pre">IFN.min_irreducible()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#IdealFlow.Network.IFN.network_delete_cloud"><code class="docutils literal notranslate"><span class="pre">IFN.network_delete_cloud()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#IdealFlow.Network.IFN.network_entropy"><code class="docutils literal notranslate"><span class="pre">IFN.network_entropy</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#IdealFlow.Network.IFN.network_entropy_matrix"><code class="docutils literal notranslate"><span class="pre">IFN.network_entropy_matrix()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#IdealFlow.Network.IFN.network_entropy_ratio"><code class="docutils literal notranslate"><span class="pre">IFN.network_entropy_ratio</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#IdealFlow.Network.IFN.network_entropy_ratio_matrix"><code class="docutils literal notranslate"><span class="pre">IFN.network_entropy_ratio_matrix()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#IdealFlow.Network.IFN.network_probability"><code class="docutils literal notranslate"><span class="pre">IFN.network_probability</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#IdealFlow.Network.IFN.node_index"><code class="docutils literal notranslate"><span class="pre">IFN.node_index()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#IdealFlow.Network.IFN.node_name"><code class="docutils literal notranslate"><span class="pre">IFN.node_name()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#IdealFlow.Network.IFN.nodes"><code class="docutils literal notranslate"><span class="pre">IFN.nodes</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#IdealFlow.Network.IFN.nodes_flow"><code class="docutils literal notranslate"><span class="pre">IFN.nodes_flow</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#IdealFlow.Network.IFN.num_to_excel_col"><code class="docutils literal notranslate"><span class="pre">IFN.num_to_excel_col()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#IdealFlow.Network.IFN.num_to_str_fraction"><code class="docutils literal notranslate"><span class="pre">IFN.num_to_str_fraction()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#IdealFlow.Network.IFN.order_markov_higher"><code class="docutils literal notranslate"><span class="pre">IFN.order_markov_higher()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#IdealFlow.Network.IFN.order_markov_lower"><code class="docutils literal notranslate"><span class="pre">IFN.order_markov_lower()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#IdealFlow.Network.IFN.out_degree"><code class="docutils literal notranslate"><span class="pre">IFN.out_degree</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#IdealFlow.Network.IFN.out_neighbors"><code class="docutils literal notranslate"><span class="pre">IFN.out_neighbors()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#IdealFlow.Network.IFN.out_weight"><code class="docutils literal notranslate"><span class="pre">IFN.out_weight</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#IdealFlow.Network.IFN.overlay"><code class="docutils literal notranslate"><span class="pre">IFN.overlay()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#IdealFlow.Network.IFN.parse_cycle"><code class="docutils literal notranslate"><span class="pre">IFN.parse_cycle()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#IdealFlow.Network.IFN.parse_terms_to_dict"><code class="docutils literal notranslate"><span class="pre">IFN.parse_terms_to_dict()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#IdealFlow.Network.IFN.path_distance"><code class="docutils literal notranslate"><span class="pre">IFN.path_distance()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#IdealFlow.Network.IFN.path_length"><code class="docutils literal notranslate"><span class="pre">IFN.path_length()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#IdealFlow.Network.IFN.path_sum_weight"><code class="docutils literal notranslate"><span class="pre">IFN.path_sum_weight()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#IdealFlow.Network.IFN.permutations"><code class="docutils literal notranslate"><span class="pre">IFN.permutations()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#IdealFlow.Network.IFN.premier_ifn"><code class="docutils literal notranslate"><span class="pre">IFN.premier_ifn()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#IdealFlow.Network.IFN.premier_signature"><code class="docutils literal notranslate"><span class="pre">IFN.premier_signature()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#IdealFlow.Network.IFN.query"><code class="docutils literal notranslate"><span class="pre">IFN.query()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#IdealFlow.Network.IFN.query_cycle_limit"><code class="docutils literal notranslate"><span class="pre">IFN.query_cycle_limit()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#IdealFlow.Network.IFN.rand_capacity"><code class="docutils literal notranslate"><span class="pre">IFN.rand_capacity()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#IdealFlow.Network.IFN.rand_ifn_signature"><code class="docutils literal notranslate"><span class="pre">IFN.rand_ifn_signature()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#IdealFlow.Network.IFN.rand_int"><code class="docutils literal notranslate"><span class="pre">IFN.rand_int()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#IdealFlow.Network.IFN.rand_irreducible"><code class="docutils literal notranslate"><span class="pre">IFN.rand_irreducible()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#IdealFlow.Network.IFN.rand_permutation_eye"><code class="docutils literal notranslate"><span class="pre">IFN.rand_permutation_eye()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#IdealFlow.Network.IFN.rand_stochastic"><code class="docutils literal notranslate"><span class="pre">IFN.rand_stochastic()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#IdealFlow.Network.IFN.random_cycle_from"><code class="docutils literal notranslate"><span class="pre">IFN.random_cycle_from()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#IdealFlow.Network.IFN.random_ideal_flow_matrix"><code class="docutils literal notranslate"><span class="pre">IFN.random_ideal_flow_matrix()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#IdealFlow.Network.IFN.random_ifn"><code class="docutils literal notranslate"><span class="pre">IFN.random_ifn()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#IdealFlow.Network.IFN.random_irreducible_stochastic"><code class="docutils literal notranslate"><span class="pre">IFN.random_irreducible_stochastic()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#IdealFlow.Network.IFN.random_walk_cycle"><code class="docutils literal notranslate"><span class="pre">IFN.random_walk_cycle()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#IdealFlow.Network.IFN.random_walk_from"><code class="docutils literal notranslate"><span class="pre">IFN.random_walk_from()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#IdealFlow.Network.IFN.random_walk_matrix"><code class="docutils literal notranslate"><span class="pre">IFN.random_walk_matrix()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#IdealFlow.Network.IFN.random_walk_nodes"><code class="docutils literal notranslate"><span class="pre">IFN.random_walk_nodes()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#IdealFlow.Network.IFN.read_csv"><code class="docutils literal notranslate"><span class="pre">IFN.read_csv()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#IdealFlow.Network.IFN.reduce_link_flow"><code class="docutils literal notranslate"><span class="pre">IFN.reduce_link_flow()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#IdealFlow.Network.IFN.reindex"><code class="docutils literal notranslate"><span class="pre">IFN.reindex()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#IdealFlow.Network.IFN.relabel_signature"><code class="docutils literal notranslate"><span class="pre">IFN.relabel_signature()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#IdealFlow.Network.IFN.reverse_network"><code class="docutils literal notranslate"><span class="pre">IFN.reverse_network()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#IdealFlow.Network.IFN.reverse_relabel_signature"><code class="docutils literal notranslate"><span class="pre">IFN.reverse_relabel_signature()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#IdealFlow.Network.IFN.row_stochastic"><code class="docutils literal notranslate"><span class="pre">IFN.row_stochastic</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#IdealFlow.Network.IFN.save"><code class="docutils literal notranslate"><span class="pre">IFN.save()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#IdealFlow.Network.IFN.save_adj_list"><code class="docutils literal notranslate"><span class="pre">IFN.save_adj_list()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#IdealFlow.Network.IFN.set_data"><code class="docutils literal notranslate"><span class="pre">IFN.set_data()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#IdealFlow.Network.IFN.set_link_weight"><code class="docutils literal notranslate"><span class="pre">IFN.set_link_weight()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#IdealFlow.Network.IFN.set_link_weight_plus_1"><code class="docutils literal notranslate"><span class="pre">IFN.set_link_weight_plus_1()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#IdealFlow.Network.IFN.set_matrix"><code class="docutils literal notranslate"><span class="pre">IFN.set_matrix()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#IdealFlow.Network.IFN.set_path"><code class="docutils literal notranslate"><span class="pre">IFN.set_path()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#IdealFlow.Network.IFN.shortest_path"><code class="docutils literal notranslate"><span class="pre">IFN.shortest_path()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#IdealFlow.Network.IFN.show"><code class="docutils literal notranslate"><span class="pre">IFN.show()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#IdealFlow.Network.IFN.signature_coef_to_1"><code class="docutils literal notranslate"><span class="pre">IFN.signature_coef_to_1()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#IdealFlow.Network.IFN.signature_to_adj_list"><code class="docutils literal notranslate"><span class="pre">IFN.signature_to_adj_list()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#IdealFlow.Network.IFN.signature_to_coef_flow"><code class="docutils literal notranslate"><span class="pre">IFN.signature_to_coef_flow()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#IdealFlow.Network.IFN.signature_to_column_stochastic"><code class="docutils literal notranslate"><span class="pre">IFN.signature_to_column_stochastic()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#IdealFlow.Network.IFN.signature_to_ideal_flow"><code class="docutils literal notranslate"><span class="pre">IFN.signature_to_ideal_flow()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#IdealFlow.Network.IFN.signature_to_kappa"><code class="docutils literal notranslate"><span class="pre">IFN.signature_to_kappa()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#IdealFlow.Network.IFN.signature_to_link_flow"><code class="docutils literal notranslate"><span class="pre">IFN.signature_to_link_flow()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#IdealFlow.Network.IFN.signature_to_links"><code class="docutils literal notranslate"><span class="pre">IFN.signature_to_links()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#IdealFlow.Network.IFN.signature_to_max_flow"><code class="docutils literal notranslate"><span class="pre">IFN.signature_to_max_flow()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#IdealFlow.Network.IFN.signature_to_min_flow"><code class="docutils literal notranslate"><span class="pre">IFN.signature_to_min_flow()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#IdealFlow.Network.IFN.signature_to_num_links"><code class="docutils literal notranslate"><span class="pre">IFN.signature_to_num_links()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#IdealFlow.Network.IFN.signature_to_num_nodes"><code class="docutils literal notranslate"><span class="pre">IFN.signature_to_num_nodes()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#IdealFlow.Network.IFN.signature_to_pivots"><code class="docutils literal notranslate"><span class="pre">IFN.signature_to_pivots()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#IdealFlow.Network.IFN.signature_to_row_stochastic"><code class="docutils literal notranslate"><span class="pre">IFN.signature_to_row_stochastic()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#IdealFlow.Network.IFN.signature_to_sum_cols"><code class="docutils literal notranslate"><span class="pre">IFN.signature_to_sum_cols()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#IdealFlow.Network.IFN.signature_to_sum_rows"><code class="docutils literal notranslate"><span class="pre">IFN.signature_to_sum_rows()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#IdealFlow.Network.IFN.solve_cycles"><code class="docutils literal notranslate"><span class="pre">IFN.solve_cycles()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#IdealFlow.Network.IFN.stationary_markov_chain"><code class="docutils literal notranslate"><span class="pre">IFN.stationary_markov_chain()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#IdealFlow.Network.IFN.stdev_flow"><code class="docutils literal notranslate"><span class="pre">IFN.stdev_flow</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#IdealFlow.Network.IFN.stdev_flow_matrix"><code class="docutils literal notranslate"><span class="pre">IFN.stdev_flow_matrix()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#IdealFlow.Network.IFN.stochastic_to_entropy_ratio"><code class="docutils literal notranslate"><span class="pre">IFN.stochastic_to_entropy_ratio()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#IdealFlow.Network.IFN.stochastic_to_ideal_flow"><code class="docutils literal notranslate"><span class="pre">IFN.stochastic_to_ideal_flow()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#IdealFlow.Network.IFN.stochastic_to_network_entropy"><code class="docutils literal notranslate"><span class="pre">IFN.stochastic_to_network_entropy()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#IdealFlow.Network.IFN.stochastic_to_pi"><code class="docutils literal notranslate"><span class="pre">IFN.stochastic_to_pi()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#IdealFlow.Network.IFN.stochastic_to_probability"><code class="docutils literal notranslate"><span class="pre">IFN.stochastic_to_probability()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#IdealFlow.Network.IFN.str_to_num"><code class="docutils literal notranslate"><span class="pre">IFN.str_to_num()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#IdealFlow.Network.IFN.string_to_matrix"><code class="docutils literal notranslate"><span class="pre">IFN.string_to_matrix()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#IdealFlow.Network.IFN.sum_dict_values"><code class="docutils literal notranslate"><span class="pre">IFN.sum_dict_values()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#IdealFlow.Network.IFN.sum_of_col"><code class="docutils literal notranslate"><span class="pre">IFN.sum_of_col()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#IdealFlow.Network.IFN.sum_of_row"><code class="docutils literal notranslate"><span class="pre">IFN.sum_of_row()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#IdealFlow.Network.IFN.to_adjacency_matrix"><code class="docutils literal notranslate"><span class="pre">IFN.to_adjacency_matrix()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#IdealFlow.Network.IFN.to_base62"><code class="docutils literal notranslate"><span class="pre">IFN.to_base62()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#IdealFlow.Network.IFN.to_equal_inflow"><code class="docutils literal notranslate"><span class="pre">IFN.to_equal_inflow()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#IdealFlow.Network.IFN.to_equal_outflow"><code class="docutils literal notranslate"><span class="pre">IFN.to_equal_outflow()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#IdealFlow.Network.IFN.to_graph"><code class="docutils literal notranslate"><span class="pre">IFN.to_graph()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#IdealFlow.Network.IFN.to_markov_order"><code class="docutils literal notranslate"><span class="pre">IFN.to_markov_order()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#IdealFlow.Network.IFN.total_flow"><code class="docutils literal notranslate"><span class="pre">IFN.total_flow</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#IdealFlow.Network.IFN.total_links"><code class="docutils literal notranslate"><span class="pre">IFN.total_links</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#IdealFlow.Network.IFN.total_nodes"><code class="docutils literal notranslate"><span class="pre">IFN.total_nodes</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#IdealFlow.Network.IFN.trajectory_to_links"><code class="docutils literal notranslate"><span class="pre">IFN.trajectory_to_links()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#IdealFlow.Network.IFN.union"><code class="docutils literal notranslate"><span class="pre">IFN.union()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#IdealFlow.Network.IFN.universe"><code class="docutils literal notranslate"><span class="pre">IFN.universe()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#IdealFlow.Network.IFN.unlearn"><code class="docutils literal notranslate"><span class="pre">IFN.unlearn()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#IdealFlow.Network.IFN.weighted_random_choice"><code class="docutils literal notranslate"><span class="pre">IFN.weighted_random_choice()</span></code></a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1 current"><a class="reference internal" href="modules.html">IdealFlow</a><ul class="current">
<li class="toctree-l2 current"><a class="current reference internal" href="#">Ideal Flow Package</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#module-IdealFlow">Module contents</a></li>
<li class="toctree-l3"><a class="reference internal" href="#submodules">Submodules</a></li>
<li class="toctree-l3"><a class="reference internal" href="#module-IdealFlow.Network">IdealFlow.Network module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#ideal-flow-network">Ideal Flow Network</a></li>
<li class="toctree-l4"><a class="reference internal" href="#IdealFlow.Network.IFN"><code class="docutils literal notranslate"><span class="pre">IFN</span></code></a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="data_management.html">Data Management Methods</a></li>
<li class="toctree-l1"><a class="reference internal" href="node_management.html">Node Management</a></li>
<li class="toctree-l1"><a class="reference internal" href="link_management.html">Link Management</a></li>
<li class="toctree-l1"><a class="reference internal" href="flow_management.html">Flow Management</a></li>
<li class="toctree-l1"><a class="reference internal" href="adjList.html">Adjacency List Operations</a></li>
<li class="toctree-l1"><a class="reference internal" href="path.html">Path and Trajectory Analysis</a></li>
<li class="toctree-l1"><a class="reference internal" href="network_indices.html">Network Indices</a></li>
<li class="toctree-l1"><a class="reference internal" href="network_operation.html">Network Operations</a></li>
<li class="toctree-l1"><a class="reference internal" href="matrix.html">Matrix Operations</a></li>
<li class="toctree-l1"><a class="reference internal" href="stochastic.html">Stochastic and Probability</a></li>
<li class="toctree-l1"><a class="reference internal" href="markov.html">Markov Chain Analysis</a></li>
<li class="toctree-l1"><a class="reference internal" href="query_methods.html">Query and Search Methods</a></li>
<li class="toctree-l1"><a class="reference internal" href="neighborhood.html">Neighborhood</a></li>
<li class="toctree-l1"><a class="reference internal" href="ifn.html">Ideal Flow Network</a></li>
<li class="toctree-l1"><a class="reference internal" href="random_walk.html">Random Walk and Random Cycle</a></li>
<li class="toctree-l1"><a class="reference internal" href="entropy.html">Entropy</a></li>
<li class="toctree-l1"><a class="reference internal" href="cycle_analysis.html">Cycle Analysis</a></li>
<li class="toctree-l1"><a class="reference internal" href="signature_analysis.html">Signature Analysis</a></li>
<li class="toctree-l1"><a class="reference internal" href="utility.html">Utilities and Helper Methods</a></li>
<li class="toctree-l1"><a class="reference internal" href="data_science_ai.html">Data Science, Machine Learning and Artificial Intelligence</a></li>
<li class="toctree-l1"><a class="reference internal" href="transportation_analysis.html">Transportation Analysis</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">Ideal Flow Network (IFN)</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">Ideal Flow Package</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/IdealFlow.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="ideal-flow-package">
<h1>Ideal Flow Package<a class="headerlink" href="#ideal-flow-package" title="Link to this heading"></a></h1>
<section id="module-IdealFlow">
<span id="module-contents"></span><h2>Module contents<a class="headerlink" href="#module-IdealFlow" title="Link to this heading"></a></h2>
</section>
<section id="submodules">
<h2>Submodules<a class="headerlink" href="#submodules" title="Link to this heading"></a></h2>
</section>
<section id="module-IdealFlow.Network">
<span id="idealflow-network-module"></span><h2>IdealFlow.Network module<a class="headerlink" href="#module-IdealFlow.Network" title="Link to this heading"></a></h2>
<section id="ideal-flow-network">
<h3>Ideal Flow Network<a class="headerlink" href="#ideal-flow-network" title="Link to this heading"></a></h3>
<p>&#64;author: Kardi Teknomo (<a class="reference external" href="http://people.revoledu.com/kardi/">http://people.revoledu.com/kardi/</a>)</p>
<dl>
<dt>IFN Class</dt><dd><blockquote>
<div><p>Representation of an expandable Ideal Flow Network.</p>
<p>The Network class provides various methods for analyzing and manipulating nodes, links, adjacency lists, matrices,
and performing network analysis and metric, including path finding, cycles analysis, analyzing connectivity, signature, and more.
This class is designed to handle flow networks and their properties through mathematical operations and context.</p>
<dl>
<dt>Example:</dt><dd><div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">IdealFlow.Network</span> <span class="k">as</span> <span class="nn">net</span>     <span class="c1"># import package.module as alias</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="n">net</span><span class="o">.</span><span class="n">IFN</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">add_link</span><span class="p">(</span><span class="s2">&quot;New York&quot;</span><span class="p">,</span><span class="s2">&quot;Chicago&quot;</span><span class="p">,</span><span class="mi">1000</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">add_link</span><span class="p">(</span><span class="s2">&quot;Chicago&quot;</span><span class="p">,</span><span class="s2">&quot;Denver&quot;</span><span class="p">,</span><span class="mi">1000</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">add_link</span><span class="p">(</span><span class="s2">&quot;New York&quot;</span><span class="p">,</span><span class="s2">&quot;Toronto&quot;</span><span class="p">,</span><span class="mi">800</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">add_link</span><span class="p">(</span><span class="s2">&quot;New York&quot;</span><span class="p">,</span><span class="s2">&quot;Denver&quot;</span><span class="p">,</span><span class="mi">1900</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">show</span><span class="p">();</span>
</pre></div>
</div>
</dd>
</dl>
</div></blockquote>
<p> 2018-2024 Kardi Teknomo</p>
</dd>
</dl>
<p>version 1.15</p>
<p>first build: Sep 3, 2018
last update: Oct 29,2024</p>
</section>
<dl class="py class">
<dt class="sig sig-object py" id="IdealFlow.Network.IFN">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">IdealFlow.Network.</span></span><span class="sig-name descname"><span class="pre">IFN</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">''</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#IdealFlow.Network.IFN" title="Link to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Represents an Ideal Flow Network (IFN).</p>
<p>This class provides methods for managing and visualizing a directed flow network.</p>
<dl class="py method">
<dt class="sig sig-object py" id="IdealFlow.Network.IFN.abs_diff_capacity_flow">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">abs_diff_capacity_flow</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">C</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">F</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">w1</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">w2</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">float</span></span></span><a class="headerlink" href="#IdealFlow.Network.IFN.abs_diff_capacity_flow" title="Link to this definition"></a></dt>
<dd><p>Return scalar cost of the total change between capacity and flow matrix.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>C</strong> (<em>list</em>)  The capacity matrix.</p></li>
<li><p><strong>F</strong> (<em>list</em>)  The flow matrix.</p></li>
<li><p><strong>w1</strong> (<em>float</em>)  Weight for negative difference. Default is 1.</p></li>
<li><p><strong>w2</strong> (<em>float</em>)  Weight for positive difference. Default is 1.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The total cost.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">IdealFlow.Network</span> <span class="k">as</span> <span class="nn">net</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">C</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">F</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="n">net</span><span class="o">.</span><span class="n">IFN</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cost</span> <span class="o">=</span> <span class="n">n</span><span class="o">.</span><span class="n">abs_diff_capacity_flow</span><span class="p">(</span><span class="n">C</span><span class="p">,</span> <span class="n">F</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">cost</span><span class="p">)</span>
<span class="go">2.0</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="IdealFlow.Network.IFN.add_first_link">
<span class="sig-name descname"><span class="pre">add_first_link</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">startNode</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">endNode</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#IdealFlow.Network.IFN.add_first_link" title="Link to this definition"></a></dt>
<dd><p>Shortcut to add the first link in a training trajectory.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>startNode</strong> (<em>str</em>)  The starting node.</p></li>
<li><p><strong>endNode</strong> (<em>str</em>)  The ending node.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">IdealFlow.Network</span> <span class="k">as</span> <span class="nn">net</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="n">net</span><span class="o">.</span><span class="n">IFN</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">add_first_link</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">get_links</span><span class="p">)</span>
<span class="go">[[&#39;#z#&#39;, &#39;a&#39;], [&#39;a&#39;, &#39;b&#39;]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="IdealFlow.Network.IFN.add_last_link">
<span class="sig-name descname"><span class="pre">add_last_link</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">startNode</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">endNode</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#IdealFlow.Network.IFN.add_last_link" title="Link to this definition"></a></dt>
<dd><p>Shortcut to add the last link in a training trajectory.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>startNode</strong> (<em>str</em>)  The starting node.</p></li>
<li><p><strong>endNode</strong> (<em>str</em>)  The ending node.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">IdealFlow.Network</span> <span class="k">as</span> <span class="nn">net</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="n">net</span><span class="o">.</span><span class="n">IFN</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">add_last_link</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">get_links</span><span class="p">)</span>
<span class="go">[[&#39;a&#39;, &#39;b&#39;], [&#39;b&#39;, &#39;#z#&#39;]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="IdealFlow.Network.IFN.add_link">
<span class="sig-name descname"><span class="pre">add_link</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">startNode</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">endNode</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weight</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#IdealFlow.Network.IFN.add_link" title="Link to this definition"></a></dt>
<dd><p>Creates a link between two nodes with the specified weight.
If the link exists, the weight is updated.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>startNode</strong> (<em>str</em>)  The starting node of the link.</p></li>
<li><p><strong>endNode</strong> (<em>str</em>)  The ending node of the link.</p></li>
<li><p><strong>weight</strong> (<em>float</em>)  The weight of the link. Defaults to 1.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">IdealFlow.Network</span> <span class="k">as</span> <span class="nn">net</span>     <span class="c1"># import package.module as alias</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="n">net</span><span class="o">.</span><span class="n">IFN</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">add_link</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">get_link_flow</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">))</span>
<span class="go">5.0</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="IdealFlow.Network.IFN.add_node">
<span class="sig-name descname"><span class="pre">add_node</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">nodeName</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#IdealFlow.Network.IFN.add_node" title="Link to this definition"></a></dt>
<dd><p>Adds a new node to the network if it does not already exist.
Useful for adding an isolated node</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>node</strong> (<em>str</em>)  The name or identifier of the node to be added.</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">IdealFlow.Network</span> <span class="k">as</span> <span class="nn">net</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="n">net</span><span class="o">.</span><span class="n">IFN</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="s1">&#39;a&#39;</span> <span class="ow">in</span> <span class="n">n</span><span class="o">.</span><span class="n">listNodes</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="IdealFlow.Network.IFN.add_random_ones">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">add_random_ones</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">A</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">m</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">6</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">ndarray</span></span></span><a class="headerlink" href="#IdealFlow.Network.IFN.add_random_ones" title="Link to this definition"></a></dt>
<dd><p>Add random ones to a matrix until the total number of ones is equal to m.</p>
<p>Add 1 to the matrix A at random cell location such that the total 1 in the matrix is equal to m. If total number of 1 is less than m, it will not be added.
It will not add anything if the current number of ones is already larger than m</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>A</strong> (<em>np.ndarray</em>)  The input square matrix.</p></li>
<li><p><strong>m</strong> (<em>int</em>)  The number of ones to add. Default is 6.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The updated matrix.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>np.ndarray</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">IdealFlow.Network</span> <span class="k">as</span> <span class="nn">net</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="n">net</span><span class="o">.</span><span class="n">IFN</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">updated_A</span> <span class="o">=</span> <span class="n">n</span><span class="o">.</span><span class="n">add_random_ones</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">updated_A</span><span class="p">)</span>
<span class="go">[[0 1 0]</span>
<span class="go"> [1 0 0]</span>
<span class="go"> [0 1 1]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="IdealFlow.Network.IFN.adj_list_to_matrix">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">adj_list_to_matrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">adjL</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">dict</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">ndarray</span></span></span><a class="headerlink" href="#IdealFlow.Network.IFN.adj_list_to_matrix" title="Link to this definition"></a></dt>
<dd><p>Convert an adjacency list to a weighted square matrix.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>adjL</strong> (<em>dict</em>)  The adjacency list.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The weighted square matrix.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>np.ndarray</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">IdealFlow.Network</span> <span class="k">as</span> <span class="nn">net</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="n">net</span><span class="o">.</span><span class="n">IFN</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">adjL</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;a&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;b&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">},</span> <span class="s1">&#39;b&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;c&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span> <span class="s1">&#39;c&#39;</span><span class="p">:</span> <span class="p">{}}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">matrix</span> <span class="o">=</span> <span class="n">n</span><span class="o">.</span><span class="n">adj_list_to_matrix</span><span class="p">(</span><span class="n">adjL</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">matrix</span><span class="p">)</span>
<span class="go">[[0 1 2]</span>
<span class="go"> [0 0 3]</span>
<span class="go"> [0 0 0]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="IdealFlow.Network.IFN.adjacency_to_ideal_flow">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">adjacency_to_ideal_flow</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">A</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kappa</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">list</span></span></span><a class="headerlink" href="#IdealFlow.Network.IFN.adjacency_to_ideal_flow" title="Link to this definition"></a></dt>
<dd><p>Convert adjacency matrix to ideal flow matrix.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>A</strong> (<em>list</em>)  The adjacency matrix.</p></li>
<li><p><strong>kappa</strong> (<em>float</em>)  The kappa parameter.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The ideal flow matrix.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>list</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">IdealFlow.Network</span> <span class="k">as</span> <span class="nn">net</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="n">net</span><span class="o">.</span><span class="n">IFN</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ideal_flow</span> <span class="o">=</span> <span class="n">n</span><span class="o">.</span><span class="n">adjacency_to_ideal_flow</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">ideal_flow</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="IdealFlow.Network.IFN.adjacency_to_stochastic">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">adjacency_to_stochastic</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">A</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">list</span></span></span><a class="headerlink" href="#IdealFlow.Network.IFN.adjacency_to_stochastic" title="Link to this definition"></a></dt>
<dd><p>Convert adjacency matrix to stochastic matrix of equal outflow distribution.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>A</strong> (<em>list</em>)  The adjacency matrix.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The stochastic matrix.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>list</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">IdealFlow.Network</span> <span class="k">as</span> <span class="nn">net</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="n">net</span><span class="o">.</span><span class="n">IFN</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">stochastic_matrix</span> <span class="o">=</span> <span class="n">n</span><span class="o">.</span><span class="n">adjacency_to_stochastic</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">stochastic_matrix</span><span class="p">)</span>
<span class="go">[[0, 1], [1, 0]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="IdealFlow.Network.IFN.all_shortest_path">
<span class="sig-name descname"><span class="pre">all_shortest_path</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">tuple</span></span></span><a class="headerlink" href="#IdealFlow.Network.IFN.all_shortest_path" title="Link to this definition"></a></dt>
<dd><p>Return the matrix of all shortest paths using the Floyd-Warshall algorithm.
note: this is min weight path, not min number of links.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>A tuple containing the shortest path matrix and the list of nodes.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>tuple</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">IdealFlow.Network</span> <span class="k">as</span> <span class="nn">net</span>     <span class="c1"># import package.module as alias</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="n">net</span><span class="o">.</span><span class="n">IFN</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">add_link</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">add_link</span><span class="p">(</span><span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">all_shortest_path</span><span class="p">()</span>
<span class="go">(array([[0., 1., 2.], [inf, 0., 1.], [inf, inf, 0.]]), [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="IdealFlow.Network.IFN.alphabet_list">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">alphabet_list</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">list</span></span></span><a class="headerlink" href="#IdealFlow.Network.IFN.alphabet_list" title="Link to this definition"></a></dt>
<dd><p>Convert an integer to its corresponding ASCII character.
Useful to generate list of nodes.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>n</strong> (<em>int</em>)  The number of characters to generate.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A list of characters from a to the n-th character.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>list</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">IdealFlow.Network</span> <span class="k">as</span> <span class="nn">net</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="n">net</span><span class="o">.</span><span class="n">IFN</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">alphabet</span> <span class="o">=</span> <span class="n">n</span><span class="o">.</span><span class="n">alphabet_list</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">alphabet</span><span class="p">)</span>
<span class="go">[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="IdealFlow.Network.IFN.assign">
<span class="sig-name descname"><span class="pre">assign</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">trajectory</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#IdealFlow.Network.IFN.assign" title="Link to this definition"></a></dt>
<dd><p>Assign a trajectory to the network by updating link weights.</p>
<dl class="simple">
<dt>Alias:</dt><dd><p><cite>set_path(rajectory,1)</cite></p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>trajectory</strong> (<em>list</em>)  A list of nodes representing the trajectory (node sequence) to be assigned.</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">IdealFlow.Network</span> <span class="k">as</span> <span class="nn">net</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="n">net</span><span class="o">.</span><span class="n">IFN</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">assign</span><span class="p">([</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="IdealFlow.Network.IFN.assign_adjacency_list">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">assign_adjacency_list</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">value</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">trajectory</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">is_cycle</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">dict</span></span></span><a class="headerlink" href="#IdealFlow.Network.IFN.assign_adjacency_list" title="Link to this definition"></a></dt>
<dd><p>Assign a value to a sequence of nodes, creating an adjacency list.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>value</strong> (<em>float</em>)  The value to assign to the edges in the sequence.</p></li>
<li><p><strong>trajectory</strong> (<em>str</em>)  The sequence of nodes.</p></li>
<li><p><strong>is_cycle</strong> (<em>bool</em>)  Whether the sequence represents a cycle (default is True).</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The adjacency list representation of the trajectory.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>dict</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">IdealFlow.Network</span> <span class="k">as</span> <span class="nn">net</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="n">net</span><span class="o">.</span><span class="n">IFN</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">assign_adjacency_list</span><span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="s2">&quot;abc&quot;</span><span class="p">)</span>
<span class="go">{&#39;a&#39;: {&#39;b&#39;: 1.0}, &#39;b&#39;: {&#39;c&#39;: 1.0}, &#39;c&#39;: {&#39;a&#39;: 1.0}}</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="IdealFlow.Network.IFN.assign_cycle_to_matrix">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">assign_cycle_to_matrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">F</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cycle</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">value</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#IdealFlow.Network.IFN.assign_cycle_to_matrix" title="Link to this definition"></a></dt>
<dd><p>Assign a value to the edges in a cycle within the flow matrix.
return F by reference</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>F</strong> (<em>np.ndarray</em>)  The flow matrix.</p></li>
<li><p><strong>cycle</strong> (<em>list</em>)  The cycle as a list of node indices.</p></li>
<li><p><strong>value</strong> (<em>number</em>)  The value to assign to the edges.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">IdealFlow.Network</span> <span class="k">as</span> <span class="nn">net</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="n">net</span><span class="o">.</span><span class="n">IFN</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">F</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">assign_cycle_to_matrix</span><span class="p">(</span><span class="n">F</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">F</span>
<span class="go">array([[0, 5, 0],</span>
<span class="go">       [0, 0, 5],</span>
<span class="go">       [5, 0, 0]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">F</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cycle</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">assign_cycle_to_matrix</span><span class="p">(</span><span class="n">F</span><span class="p">,</span> <span class="n">cycle</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">[[0, 1], [1, 0]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="IdealFlow.Network.IFN.association_predict_actor_net">
<span class="sig-name descname"><span class="pre">association_predict_actor_net</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">netActor</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">netSystem</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#IdealFlow.Network.IFN.association_predict_actor_net" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="IdealFlow.Network.IFN.association_predict_trajectory">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">association_predict_trajectory</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">trajectory</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">net</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">dict</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">tuple</span></span></span><a class="headerlink" href="#IdealFlow.Network.IFN.association_predict_trajectory" title="Link to this definition"></a></dt>
<dd><p>Predict associations of itemset from a trajectory based on the networks direct links.</p>
<p>Given a trajectory and IFN, predict the association of itemset based on direct link from trajectory complete graph to the IFN that is not in the complete graph.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>trajectory</strong> (<em>list</em>)  A list of nodes representing the trajectory.</p></li>
<li><p><strong>net</strong> (<em>dict</em>)  The IFN.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><p>A dictionary of predictions (item -&gt; flow), total support, and total confidence.</p>
<p>prediction = sorted dictionary of item: flow
supp=count of flow in trajectory items
conf=count of flow in all direct links</p>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>tuple</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">IdealFlow.Network</span> <span class="k">as</span> <span class="nn">net</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="n">net</span><span class="o">.</span><span class="n">IFN</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">association_predict_trajectory</span><span class="p">([</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">],</span> <span class="p">{})</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="IdealFlow.Network.IFN.association_train">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">association_train</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">trajectory</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">net</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">dict</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">dict</span></span></span><a class="headerlink" href="#IdealFlow.Network.IFN.association_train" title="Link to this definition"></a></dt>
<dd><p>Train the IFN for association based on a trajectory by creating a complete graph and overlaying it onto the IFN.
It assumes to have two ways link permutation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>trajectory</strong> (<em>list</em>)  A list of nodes representing the trajectory.</p></li>
<li><p><strong>net</strong> (<em>dict</em>)  The initial IFN (or an empty IFN).</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The updated IFN.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>dict</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">IdealFlow.Network</span> <span class="k">as</span> <span class="nn">net</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="n">net</span><span class="o">.</span><span class="n">IFN</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">association_train</span><span class="p">([</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">],</span> <span class="p">{})</span>
</pre></div>
</div>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="IdealFlow.Network.IFN.average_flow">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">average_flow</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">float</span></em><a class="headerlink" href="#IdealFlow.Network.IFN.average_flow" title="Link to this definition"></a></dt>
<dd><p>Return the internal average flow in the network</p>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">IdealFlow.Network</span> <span class="k">as</span> <span class="nn">net</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">C</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="n">net</span><span class="o">.</span><span class="n">IFN</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">set_matrix</span><span class="p">(</span><span class="n">C</span><span class="p">,[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span><span class="s1">&#39;b&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">average_flow</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="IdealFlow.Network.IFN.average_flow_matrix">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">average_flow_matrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">F</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">float</span></span></span><a class="headerlink" href="#IdealFlow.Network.IFN.average_flow_matrix" title="Link to this definition"></a></dt>
<dd><p>Compute the average flow value of a flow matrix.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>F</strong> (<em>list</em>)  The flow matrix.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The average flow value.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">IdealFlow.Network</span> <span class="k">as</span> <span class="nn">net</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">F</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="n">net</span><span class="o">.</span><span class="n">IFN</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">avg_flow_value</span> <span class="o">=</span> <span class="n">n</span><span class="o">.</span><span class="n">average_flow_matrix</span><span class="p">(</span><span class="n">F</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">avg_flow_value</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="IdealFlow.Network.IFN.average_node_entropy">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">average_node_entropy</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">float</span></em><a class="headerlink" href="#IdealFlow.Network.IFN.average_node_entropy" title="Link to this definition"></a></dt>
<dd><p>Compute average node entropy from stochastic matrix.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>S</strong> (<em>list</em>)  The stochastic matrix.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The average node entropy.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">IdealFlow.Network</span> <span class="k">as</span> <span class="nn">net</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">F</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="n">net</span><span class="o">.</span><span class="n">IFN</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">set_matrix</span><span class="p">(</span><span class="n">F</span><span class="p">,[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span><span class="s1">&#39;b&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">avg_entropy</span> <span class="o">=</span> <span class="n">n</span><span class="o">.</span><span class="n">average_node_entropy</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">avg_entropy</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="IdealFlow.Network.IFN.average_node_entropy_matrix">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">average_node_entropy_matrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">F</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">float</span></span></span><a class="headerlink" href="#IdealFlow.Network.IFN.average_node_entropy_matrix" title="Link to this definition"></a></dt>
<dd><p>Compute average node entropy for a given flow matrix.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>F</strong> (<em>list</em>)  The flow matrix.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The average node entropy.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">IdealFlow.Network</span> <span class="k">as</span> <span class="nn">net</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">F</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="n">net</span><span class="o">.</span><span class="n">IFN</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">avg_entropy</span> <span class="o">=</span> <span class="n">n</span><span class="o">.</span><span class="n">average_node_entropy_matrix</span><span class="p">(</span><span class="n">F</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">avg_entropy</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="IdealFlow.Network.IFN.average_node_entropy_ratio">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">average_node_entropy_ratio</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">float</span></em><a class="headerlink" href="#IdealFlow.Network.IFN.average_node_entropy_ratio" title="Link to this definition"></a></dt>
<dd><p>Return the internal average node entropy ratio of flows in the network</p>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">IdealFlow.Network</span> <span class="k">as</span> <span class="nn">net</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">C</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="n">net</span><span class="o">.</span><span class="n">IFN</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">set_matrix</span><span class="p">(</span><span class="n">C</span><span class="p">,[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span><span class="s1">&#39;b&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">average_node_entropy_ratio</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="IdealFlow.Network.IFN.average_node_entropy_ratio_matrix">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">average_node_entropy_ratio_matrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">F</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">float</span></span></span><a class="headerlink" href="#IdealFlow.Network.IFN.average_node_entropy_ratio_matrix" title="Link to this definition"></a></dt>
<dd><p>Compute average node entropy ratio for a given flow matrix.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>F</strong> (<em>list</em>)  The flow matrix.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The average node entropy ratio.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">IdealFlow.Network</span> <span class="k">as</span> <span class="nn">net</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">F</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="n">net</span><span class="o">.</span><span class="n">IFN</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ratio</span> <span class="o">=</span> <span class="n">n</span><span class="o">.</span><span class="n">average_node_entropy_ratio_matrix</span><span class="p">(</span><span class="n">F</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">ratio</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="IdealFlow.Network.IFN.backtracking">
<span class="sig-name descname"><span class="pre">backtracking</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">startNode</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">endNode</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">list</span></span></span><a class="headerlink" href="#IdealFlow.Network.IFN.backtracking" title="Link to this definition"></a></dt>
<dd><p>Perform DFS traversal with backtracking to find a path from startNode to endNode.</p>
<p>This method is specifically designed to find a valid path between two nodes. It explores routes, and if
it encounters a dead-end or an invalid path, it backtracks to explore other possible routes.</p>
<p>Use this method when you want to find an exact path between two nodes, potentially with constraints.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>startNode</strong> (<em>str</em>)  The starting node of the path.</p></li>
<li><p><strong>endNode</strong> (<em>str</em>)  The target node to reach.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A list of nodes forming the valid path from startNode to endNode using backtracking.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>list</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">IdealFlow.Network</span> <span class="k">as</span> <span class="nn">net</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="n">net</span><span class="o">.</span><span class="n">IFN</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">add_link</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">add_link</span><span class="p">(</span><span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">add_link</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;d&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">backtracking</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">)</span>
<span class="go">[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="IdealFlow.Network.IFN.backtracking_cycle_limit">
<span class="sig-name descname"><span class="pre">backtracking_cycle_limit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">startNode</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">endNode</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_internal_cycle</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">visited_nodes</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cycles</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">path</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#IdealFlow.Network.IFN.backtracking_cycle_limit" title="Link to this definition"></a></dt>
<dd><p>Perform DFS traversal with backtracking to find a path from startNode to endNode,
limiting the number of internal cycles.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>startNode</strong> (<em>str</em>)  The starting node.</p></li>
<li><p><strong>endNode</strong> (<em>str</em>)  The target node.</p></li>
<li><p><strong>max_internal_cycle</strong> (<em>int</em>)  The maximum number of internal cycles allowed.</p></li>
<li><p><strong>visited_nodes</strong> (<em>set</em>)  The set of nodes already visited in the path.</p></li>
<li><p><strong>cycles</strong> (<em>dict</em>)  A dictionary containing the current cycle count.</p></li>
<li><p><strong>path</strong> (<em>list</em>)  The current path.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A list of nodes forming the path from startNode to endNode.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>list</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="IdealFlow.Network.IFN.bfs">
<span class="sig-name descname"><span class="pre">bfs</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">startNode</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">list</span></span></span><a class="headerlink" href="#IdealFlow.Network.IFN.bfs" title="Link to this definition"></a></dt>
<dd><p>Perform Breadth-First Search (BFS) traversal starting from startNode.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>startNode</strong> (<em>str</em>)  The starting node.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A list of nodes visited during BFS traversal.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>list</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">IdealFlow.Network</span> <span class="k">as</span> <span class="nn">net</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="n">net</span><span class="o">.</span><span class="n">IFN</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">add_link</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">add_link</span><span class="p">(</span><span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">bfs</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">)</span>
<span class="go">[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="IdealFlow.Network.IFN.bfs_until">
<span class="sig-name descname"><span class="pre">bfs_until</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">startNode</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">endNode</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">list</span></span></span><a class="headerlink" href="#IdealFlow.Network.IFN.bfs_until" title="Link to this definition"></a></dt>
<dd><p>Perform Breadth-First Search (BFS) traversal starting from startNode until endNode is reached.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>startNode</strong> (<em>str</em>)  The starting node.</p></li>
<li><p><strong>endNode</strong> (<em>str</em>)  The target node.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A list of nodes visited during BFS traversal until endNode is reached.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>list</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">IdealFlow.Network</span> <span class="k">as</span> <span class="nn">net</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="n">net</span><span class="o">.</span><span class="n">IFN</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">add_link</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">add_link</span><span class="p">(</span><span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">bfs_until</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">)</span>
<span class="go">[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="IdealFlow.Network.IFN.binarized_matrix">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">binarized_matrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">M</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">list</span></span></span><a class="headerlink" href="#IdealFlow.Network.IFN.binarized_matrix" title="Link to this definition"></a></dt>
<dd><p>Convert the matrix to a binary (0, 1) matrix.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>M</strong> (<em>list</em>)  The input matrix.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The binarized (0, 1) version of the matrix.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>list</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">IdealFlow.Network</span> <span class="k">as</span> <span class="nn">net</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="n">net</span><span class="o">.</span><span class="n">IFN</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">matrix</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bin_matrix</span> <span class="o">=</span> <span class="n">n</span><span class="o">.</span><span class="n">binarized_matrix</span><span class="p">(</span><span class="n">matrix</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">bin_matrix</span><span class="p">)</span>
<span class="go">[[0, 1], [1, 0]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="IdealFlow.Network.IFN.canonize">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">canonize</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">cycle</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">str</span></span></span><a class="headerlink" href="#IdealFlow.Network.IFN.canonize" title="Link to this definition"></a></dt>
<dd><p>Canonize a string cycle by rotating it to its lexicographically smallest form.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>cycle</strong> (<em>str</em>)  The string cycle, each letter represent a node.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The canonized string cycle.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>str</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">IdealFlow.Network</span> <span class="k">as</span> <span class="nn">net</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="n">net</span><span class="o">.</span><span class="n">IFN</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cycle</span> <span class="o">=</span> <span class="s1">&#39;bca&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">canonized</span> <span class="o">=</span> <span class="n">n</span><span class="o">.</span><span class="n">canonize</span><span class="p">(</span><span class="n">cycle</span><span class="p">)</span>
<span class="go">abc</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">canonize</span><span class="p">(</span><span class="s2">&quot;fde&quot;</span><span class="p">)</span>
<span class="go">def</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="IdealFlow.Network.IFN.canonize_cycle_dict">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">canonize_cycle_dict</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">cycle_dict</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">dict</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">dict</span></span></span><a class="headerlink" href="#IdealFlow.Network.IFN.canonize_cycle_dict" title="Link to this definition"></a></dt>
<dd><p>Canonize a cycle dictionary by sorting and normalizing the cycles.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>cycle_dict</strong> (<em>dict</em>)  The cycle dictionary.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The canonized cycle dictionary.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>dict</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">IdealFlow.Network</span> <span class="k">as</span> <span class="nn">net</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="n">net</span><span class="o">.</span><span class="n">IFN</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cycle_dict</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;bca&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;cab&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">canonize_cycle_dict</span><span class="p">(</span><span class="n">cycle_dict</span><span class="p">)</span>
<span class="go">{&#39;abc&#39;: 3}</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="IdealFlow.Network.IFN.canonize_signature">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">canonize_signature</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">signature</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">str</span></span></span><a class="headerlink" href="#IdealFlow.Network.IFN.canonize_signature" title="Link to this definition"></a></dt>
<dd><p>Canonize a network signature by relabeling the nodes and sorting the cycles.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>signature</strong> (<em>str</em>)  The network signature.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The canonized signature.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>str</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">IdealFlow.Network</span> <span class="k">as</span> <span class="nn">net</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="n">net</span><span class="o">.</span><span class="n">IFN</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">signature</span> <span class="o">=</span> <span class="s2">&quot;bca + cab&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">canonize_signature</span><span class="p">(</span><span class="n">signature</span><span class="p">)</span>
<span class="go">2abc</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="IdealFlow.Network.IFN.capacity_to_adjacency">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">capacity_to_adjacency</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">matrix</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#IdealFlow.Network.IFN.capacity_to_adjacency" title="Link to this definition"></a></dt>
<dd><p>Convert a non-negative matrix to a binary (0, 1) adjacency matrix.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>matrix</strong> (<em>list</em><em> of </em><em>list</em><em> of </em><em>int/float</em>)  The input matrix.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The adjacency matrix.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>np.array</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">IdealFlow.Network</span> <span class="k">as</span> <span class="nn">net</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="n">net</span><span class="o">.</span><span class="n">IFN</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">C</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">capacity_to_adjacency</span><span class="p">(</span><span class="n">C</span><span class="p">)</span>
</pre></div>
</div>
<p>Alias of <a class="reference internal" href="#IdealFlow.Network.IFN.to_adjacency_matrix" title="IdealFlow.Network.IFN.to_adjacency_matrix"><code class="xref py py-meth docutils literal notranslate"><span class="pre">to_adjacency_matrix()</span></code></a></p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#IdealFlow.Network.IFN.to_adjacency_matrix" title="IdealFlow.Network.IFN.to_adjacency_matrix"><code class="xref py py-meth docutils literal notranslate"><span class="pre">to_adjacency_matrix()</span></code></a></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="IdealFlow.Network.IFN.capacity_to_balance_inflow_outflow">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">capacity_to_balance_inflow_outflow</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">C</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lambda_</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.5</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#IdealFlow.Network.IFN.capacity_to_balance_inflow_outflow" title="Link to this definition"></a></dt>
<dd><p>Return ideal flow matrix balancing inflow and outflow from capacity matrix.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>C</strong> (<em>list</em><em> of </em><em>list</em><em> of </em><em>int/float</em>)  The capacity matrix.</p></li>
<li><p><strong>lambda</strong> (<em>float</em>)  The lambda parameter to balance inflow and outflow.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The balanced ideal flow matrix.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>list of list of int/float</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">IdealFlow.Network</span> <span class="k">as</span> <span class="nn">net</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="n">net</span><span class="o">.</span><span class="n">IFN</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">C</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">capacity_to_balance_inflow_outflow</span><span class="p">(</span><span class="n">C</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="IdealFlow.Network.IFN.capacity_to_congestion">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">capacity_to_congestion</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">C</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kappa</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">capacity_multiplier</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">list</span></span></span><a class="headerlink" href="#IdealFlow.Network.IFN.capacity_to_congestion" title="Link to this definition"></a></dt>
<dd><p>Compute congestion matrix from capacity matrix and kappa.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>C</strong> (<em>list</em>)  The capacity matrix.</p></li>
<li><p><strong>kappa</strong> (<em>float</em>)  The kappa parameter.</p></li>
<li><p><strong>capacity_multiplier</strong> (<em>float</em>)  The capacity multiplier.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The congestion matrix.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>list</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">IdealFlow.Network</span> <span class="k">as</span> <span class="nn">net</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">C</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">0</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="n">net</span><span class="o">.</span><span class="n">IFN</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">congestion</span> <span class="o">=</span> <span class="n">n</span><span class="o">.</span><span class="n">capacity_to_congestion</span><span class="p">(</span><span class="n">C</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">,</span> <span class="mf">0.75</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">congestion</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="IdealFlow.Network.IFN.capacity_to_ideal_flow">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">capacity_to_ideal_flow</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">C</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kappa</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">ndarray</span></span></span><a class="headerlink" href="#IdealFlow.Network.IFN.capacity_to_ideal_flow" title="Link to this definition"></a></dt>
<dd><p>Convert a capacity matrix into an ideal flow matrix.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>C</strong> (<em>np.ndarray</em>)  The capacity matrix.</p></li>
<li><p><strong>kappa</strong> (<em>float</em>)  The total flow. Default is 1.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The ideal flow matrix.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>np.ndarray</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">IdealFlow.Network</span> <span class="k">as</span> <span class="nn">net</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="n">net</span><span class="o">.</span><span class="n">IFN</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">C</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">F</span> <span class="o">=</span> <span class="n">n</span><span class="o">.</span><span class="n">capacity_to_ideal_flow</span><span class="p">(</span><span class="n">C</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">F</span><span class="p">)</span>
<span class="go">[[0.4 0.6]</span>
<span class="go"> [0.5 0.5]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="IdealFlow.Network.IFN.capacity_to_stochastic">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">capacity_to_stochastic</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">C</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'row'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alpha</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">beta</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-05</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">epsilon</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-10</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#IdealFlow.Network.IFN.capacity_to_stochastic" title="Link to this definition"></a></dt>
<dd><p>Convert a capacity matrix into a stochastic matrix using various methods.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>C</strong> (<em>list</em><em> of </em><em>list</em><em> of </em><em>int/float</em><em> or </em><em>2D np.array</em>)  The capacity matrix.</p></li>
<li><p><strong>method</strong> (<em>str</em>)  Method for conversion: row, col, alpha_beta_row, alpha_beta_col.</p></li>
<li><p><strong>are</strong> (<em>Options</em>)  <ul>
<li><p>row: Converts to a row stochastic matrix.</p></li>
<li><p>col: Converts to a column stochastic matrix.</p></li>
<li><p>alpha_beta_row: Uses the alpha and beta parameters for row-wise transformation.</p></li>
<li><p>alpha_beta_col: Uses the alpha and beta parameters for column-wise transformation.</p></li>
</ul>
</p></li>
<li><p><strong>alpha</strong> (<em>float</em>)  The alpha parameter, used only for alpha_beta and alpha_beta_col methods.</p></li>
<li><p><strong>beta</strong> (<em>float</em>)  The beta parameter, used only for alpha_beta and alpha_beta_col methods.</p></li>
<li><p><strong>epsilon</strong> (<em>float</em>)  A small value to avoid division by zero, used in row and col methods.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The resulting stochastic matrix.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>np.array</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">IdealFlow.Network</span> <span class="k">as</span> <span class="nn">net</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="n">net</span><span class="o">.</span><span class="n">IFN</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">C</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">capacity_to_stochastic</span><span class="p">(</span><span class="n">C</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;row&#39;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="IdealFlow.Network.IFN.cardinal_ifn_signature">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">cardinal_ifn_signature</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">A</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">str</span></span></span><a class="headerlink" href="#IdealFlow.Network.IFN.cardinal_ifn_signature" title="Link to this definition"></a></dt>
<dd><p>Find the cardinal IFN signature, which represents the minimal set of cycles that can fully describe the network.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>A</strong> (<em>list</em><em> of </em><em>list</em><em> of </em><em>float</em>)  The input matrix representing the flow between nodes.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The cardinal IFN signature.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>str</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">IdealFlow.Network</span> <span class="k">as</span> <span class="nn">net</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="n">net</span><span class="o">.</span><span class="n">IFN</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">cardinal_ifn_signature</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="go">&#39;abc&#39;</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="IdealFlow.Network.IFN.change_flow_in_cycle">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">change_flow_in_cycle</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">F</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cycle</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">tuple</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">change</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">list</span></span></span><a class="headerlink" href="#IdealFlow.Network.IFN.change_flow_in_cycle" title="Link to this definition"></a></dt>
<dd><p>Add or subtract flow matrix based on the cycle.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>F</strong> (<em>list</em>)  The flow matrix.</p></li>
<li><p><strong>cycle</strong> (<em>tuple</em><em> or </em><em>str</em>)  tuple of indices in a cycle or string cycle term</p></li>
<li><p><strong>change</strong> (<em>float</em>)  The amount to change the flow. Default is 1.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The updated flow matrix.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>list</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#IdealFlow.Network.IFN.flows_in_cycle" title="IdealFlow.Network.IFN.flows_in_cycle"><code class="xref py py-meth docutils literal notranslate"><span class="pre">flows_in_cycle()</span></code></a></p>
</div>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">IdealFlow.Network</span> <span class="k">as</span> <span class="nn">net</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="n">net</span><span class="o">.</span><span class="n">IFN</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">F</span><span class="o">=</span><span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="go">       [2, 0, 1],</span>
<span class="go">       [1, 0, 0]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">adjL</span><span class="o">=</span><span class="n">n</span><span class="o">.</span><span class="n">flow_matrix_to_adj_list</span><span class="p">(</span><span class="n">F</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">find_all_cycles_in_adj_list</span><span class="p">(</span><span class="n">adjL</span><span class="p">)</span>
<span class="go">[(0, 1), (0, 1, 2)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cycle</span> <span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">F</span> <span class="o">=</span> <span class="n">n</span><span class="o">.</span><span class="n">change_flow_in_cycle</span><span class="p">(</span><span class="n">F</span><span class="p">,</span> <span class="n">cycle</span><span class="p">,</span> <span class="n">change</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">F</span><span class="p">)</span>
<span class="go">[[0, 5, 0],</span>
<span class="go"> [2, 0, 3],</span>
<span class="go"> [3, 0, 0]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cycle</span> <span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">F</span> <span class="o">=</span> <span class="n">n</span><span class="o">.</span><span class="n">change_flow_in_cycle</span><span class="p">(</span><span class="n">F</span><span class="p">,</span> <span class="n">cycle</span><span class="p">,</span> <span class="n">change</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="go">print(F)</span>
<span class="go">[[0, 7, 0],</span>
<span class="go"> [4, 0, 3],</span>
<span class="go"> [3, 0, 0]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="IdealFlow.Network.IFN.color_graph">
<span class="sig-name descname"><span class="pre">color_graph</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">M</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">color</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pos</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">c</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="headerlink" href="#IdealFlow.Network.IFN.color_graph" title="Link to this definition"></a></dt>
<dd><p>Determines if the adjacency matrix can be colored into two colors (bipartite).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>M</strong> (<em>list</em><em> of </em><em>list</em>)  The adjacency matrix representing the graph.</p></li>
<li><p><strong>color</strong> (<em>list</em>)  The color array, with -1 representing uncolored nodes.</p></li>
<li><p><strong>pos</strong> (<em>int</em>)  The current node position.</p></li>
<li><p><strong>c</strong> (<em>int</em>)  The color to assign (0 or 1).</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>True if the graph can be colored with two colors, False otherwise.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>bool</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">IdealFlow.Network</span> <span class="k">as</span> <span class="nn">net</span>     <span class="c1"># import package.module as alias</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="n">net</span><span class="o">.</span><span class="n">IFN</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">set_matrix</span><span class="p">(</span><span class="n">M</span><span class="p">,[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span><span class="s1">&#39;b&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">color</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">M</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">color_graph</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">color</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="IdealFlow.Network.IFN.combinations">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">combinations</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">N</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">list</span></span></span><a class="headerlink" href="#IdealFlow.Network.IFN.combinations" title="Link to this definition"></a></dt>
<dd><p>Generates all combinations of the letters a through z up to length N.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>N</strong> (<em>int</em>)  The length of the desired combinations.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The list of combinations.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>list of str</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">IdealFlow.Network</span> <span class="k">as</span> <span class="nn">net</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="n">net</span><span class="o">.</span><span class="n">IFN</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">combinations</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">[&#39;a&#39;, &#39;b&#39;, &#39;ab&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">combinations</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="go">[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;ab&#39;, &#39;ac&#39;, &#39;bc&#39;, &#39;abc&#39;]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="IdealFlow.Network.IFN.complement">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">complement</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">net</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#IdealFlow.Network.IFN" title="IdealFlow.Network.IFN"><span class="pre">IFN</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#IdealFlow.Network.IFN" title="IdealFlow.Network.IFN"><span class="pre">IFN</span></a></span></span><a class="headerlink" href="#IdealFlow.Network.IFN.complement" title="Link to this definition"></a></dt>
<dd><p>Return the complement of the given network (complete graph minus the network).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>net</strong> (<a class="reference internal" href="#IdealFlow.Network.IFN" title="IdealFlow.Network.IFN"><em>IFN</em></a>)  The network to complement.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The complement of the network.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="#IdealFlow.Network.IFN" title="IdealFlow.Network.IFN">IFN</a></p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">IdealFlow.Network</span> <span class="k">as</span> <span class="nn">net</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="n">net</span><span class="o">.</span><span class="n">IFN</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">result_net</span> <span class="o">=</span> <span class="n">n</span><span class="o">.</span><span class="n">complement</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="IdealFlow.Network.IFN.complete_graph">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">complete_graph</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">trajectory</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weight</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#IdealFlow.Network.IFN" title="IdealFlow.Network.IFN"><span class="pre">IFN</span></a></span></span><a class="headerlink" href="#IdealFlow.Network.IFN.complete_graph" title="Link to this definition"></a></dt>
<dd><p>Create a complete graph from a trajectory list, with two-way links.
If trajectory has only one item, create a node.
A complete graph weight 1 is always an IFN.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>trajectory</strong> (<em>list</em>)  List of nodes.</p></li>
<li><p><strong>weight</strong> (<em>int</em>)  The weight of each link. Default is 1.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A new complete graph.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="#IdealFlow.Network.IFN" title="IdealFlow.Network.IFN">IFN</a></p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">IdealFlow.Network</span> <span class="k">as</span> <span class="nn">net</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="n">net</span><span class="o">.</span><span class="n">IFN</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">trajectory</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;B&#39;</span><span class="p">,</span> <span class="s1">&#39;C&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">complete_net</span> <span class="o">=</span> <span class="n">n</span><span class="o">.</span><span class="n">complete_graph</span><span class="p">(</span><span class="n">trajectory</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="IdealFlow.Network.IFN.compose">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">compose</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">signature</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">list</span></span></span><a class="headerlink" href="#IdealFlow.Network.IFN.compose" title="Link to this definition"></a></dt>
<dd><p>Compose a flow matrix from a network signature.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>signature</strong> (<em>str</em>)  The network signature.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The composed flow matrix.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>list of list of int/float</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#IdealFlow.Network.IFN.string_to_matrix" title="IdealFlow.Network.IFN.string_to_matrix"><code class="xref py py-meth docutils literal notranslate"><span class="pre">string_to_matrix()</span></code></a></p>
</div>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">IdealFlow.Network</span> <span class="k">as</span> <span class="nn">net</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="n">net</span><span class="o">.</span><span class="n">IFN</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">signature</span> <span class="o">=</span> <span class="s2">&quot;abc&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">compose</span><span class="p">(</span><span class="n">signature</span><span class="p">)</span>
<span class="go">array([[0., 1., 0.],</span>
<span class="go">    [0., 0., 1.],</span>
<span class="go">    [1., 0., 0.]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">compose</span><span class="p">(</span><span class="s1">&#39;ab+ba+cab&#39;</span><span class="p">)</span>
<span class="go">array([[0., 3., 0.],</span>
<span class="go">    [2., 0., 1.],</span>
<span class="go">    [1., 0., 0.]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="IdealFlow.Network.IFN.congestion">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">congestion</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">F</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">C</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">ndarray</span></span></span><a class="headerlink" href="#IdealFlow.Network.IFN.congestion" title="Link to this definition"></a></dt>
<dd><p>Compute the congestion matrix from flow and capacity matrices.
congestion matrix is element wise division of flow/capacity, except zero remain zero</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>F</strong> (<em>np.ndarray</em>)  The flow matrix.</p></li>
<li><p><strong>C</strong> (<em>np.ndarray</em>)  The capacity matrix.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The congestion matrix.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>np.ndarray</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">IdealFlow.Network</span> <span class="k">as</span> <span class="nn">net</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="n">net</span><span class="o">.</span><span class="n">IFN</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">F</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">C</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">congestion_matrix</span> <span class="o">=</span> <span class="n">n</span><span class="o">.</span><span class="n">congestion</span><span class="p">(</span><span class="n">F</span><span class="p">,</span> <span class="n">C</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">congestion_matrix</span><span class="p">)</span>
<span class="go">[[0.5 1. ]</span>
<span class="go"> [1.  0.5]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="IdealFlow.Network.IFN.copy_dict">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">copy_dict</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dic</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">dict</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">dict</span></span></span><a class="headerlink" href="#IdealFlow.Network.IFN.copy_dict" title="Link to this definition"></a></dt>
<dd><p>Create a shallow copy of a nested dictionary.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>dic</strong> (<em>dict</em>)  The dictionary to copy.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A copy of the dictionary.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>dict</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">IdealFlow.Network</span> <span class="k">as</span> <span class="nn">net</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="n">net</span><span class="o">.</span><span class="n">IFN</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;a&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="s1">&#39;b&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;c&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">}}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">copy_d</span> <span class="o">=</span> <span class="n">n</span><span class="o">.</span><span class="n">copy_dict</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">copy_d</span> <span class="o">==</span> <span class="n">d</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">copy_d</span> <span class="ow">is</span> <span class="n">d</span>
<span class="go">False</span>
</pre></div>
</div>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="IdealFlow.Network.IFN.cov_flow">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">cov_flow</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">float</span></em><a class="headerlink" href="#IdealFlow.Network.IFN.cov_flow" title="Link to this definition"></a></dt>
<dd><p>Compute the internal coefficient of variation of flows in the network.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The coefficient of variation of flow.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>float</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">IdealFlow.Network</span> <span class="k">as</span> <span class="nn">net</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">C</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="n">net</span><span class="o">.</span><span class="n">IFN</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">set_matrix</span><span class="p">(</span><span class="n">C</span><span class="p">,[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span><span class="s1">&#39;b&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">cov_flow</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="IdealFlow.Network.IFN.cov_flow_matrix">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">cov_flow_matrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">F</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">float</span></span></span><a class="headerlink" href="#IdealFlow.Network.IFN.cov_flow_matrix" title="Link to this definition"></a></dt>
<dd><p>Compute the coefficient of variation of flow values in a flow matrix.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>F</strong> (<em>list</em>)  The flow matrix.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The coefficient of variation.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">IdealFlow.Network</span> <span class="k">as</span> <span class="nn">net</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">F</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="n">net</span><span class="o">.</span><span class="n">IFN</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">coef_var</span> <span class="o">=</span> <span class="n">n</span><span class="o">.</span><span class="n">cov_flow_matrix</span><span class="p">(</span><span class="n">F</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">coef_var</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="IdealFlow.Network.IFN.create_node_mapping">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">create_node_mapping</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">net_signature</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">dict</span></span></span><a class="headerlink" href="#IdealFlow.Network.IFN.create_node_mapping" title="Link to this definition"></a></dt>
<dd><p>Create a node mapping for a network signature.
When the signature contains jump of nodes, we need to create node mapping.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>net_signature</strong> (<em>str</em>)  The network signature.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The node mapping.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>dict</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#IdealFlow.Network.IFN.relabel_signature" title="IdealFlow.Network.IFN.relabel_signature"><code class="xref py py-meth docutils literal notranslate"><span class="pre">relabel_signature()</span></code></a>
<a class="reference internal" href="#IdealFlow.Network.IFN.reverse_relabel_signature" title="IdealFlow.Network.IFN.reverse_relabel_signature"><code class="xref py py-meth docutils literal notranslate"><span class="pre">reverse_relabel_signature()</span></code></a></p>
</div>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">IdealFlow.Network</span> <span class="k">as</span> <span class="nn">net</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="n">net</span><span class="o">.</span><span class="n">IFN</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">signature</span> <span class="o">=</span> <span class="s2">&quot;abc + bcd&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mapping</span> <span class="o">=</span> <span class="n">n</span><span class="o">.</span><span class="n">create_node_mapping</span><span class="p">(</span><span class="n">signature</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">mapping</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="IdealFlow.Network.IFN.cycle_dict_to_signature">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">cycle_dict_to_signature</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">cycle_dict</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">dict</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">str</span></span></span><a class="headerlink" href="#IdealFlow.Network.IFN.cycle_dict_to_signature" title="Link to this definition"></a></dt>
<dd><p>Convert a cycle dictionary to a network signature.
The keys of cycle_dict input must be in canonical cycle.
The signature is a string of the form abc + bcd where a, b, c, d are nodes.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>cycle_dict</strong> (<em>dict</em>)  The canonical cycle dictionary.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The network signature.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>str</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">IdealFlow.Network</span> <span class="k">as</span> <span class="nn">net</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="n">net</span><span class="o">.</span><span class="n">IFN</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cycle_dict</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;abc&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;bcd&#39;</span><span class="p">:</span> <span class="o">-</span><span class="mi">1</span><span class="p">}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">signature</span> <span class="o">=</span> <span class="n">n</span><span class="o">.</span><span class="n">cycle_dict_to_signature</span><span class="p">(</span><span class="n">cycle_dict</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">signature</span><span class="p">)</span>
<span class="go">&#39;abc + (-bcd)&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cycle_dict</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;ac&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;acd&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span> <span class="s1">&#39;bc&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">cycle_dict_to_signature</span><span class="p">(</span><span class="n">cycle_dict</span><span class="p">)</span>
<span class="go">&#39;ac + 3acd + 2bc&#39;</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="IdealFlow.Network.IFN.cycle_length">
<span class="sig-name descname"><span class="pre">cycle_length</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">cycle</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">int</span></span></span><a class="headerlink" href="#IdealFlow.Network.IFN.cycle_length" title="Link to this definition"></a></dt>
<dd><p>Return the number of edges in the cycle if it forms a valid cycle, otherwise return 0.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>cycle</strong> (<em>list</em>)  A sequence of nodes forming a cycle.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The number of edges in the cycle, or 0 if not a cycle.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>int</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">IdealFlow.Network</span> <span class="k">as</span> <span class="nn">net</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="n">net</span><span class="o">.</span><span class="n">IFN</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">add_link</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">cycle_length</span><span class="p">([</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">])</span>
<span class="go">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">add_link</span><span class="p">(</span><span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">cycle_length</span><span class="p">([</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">])</span>
<span class="go">2</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="IdealFlow.Network.IFN.cycle_sum_weight">
<span class="sig-name descname"><span class="pre">cycle_sum_weight</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">cycle</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">float</span></span></span><a class="headerlink" href="#IdealFlow.Network.IFN.cycle_sum_weight" title="Link to this definition"></a></dt>
<dd><p>Return the sum of weights in the cycle if it forms a valid cycle, otherwise return 0.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>cycle</strong> (<em>list</em>)  A sequence of nodes forming a cycle.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The sum of weights in the cycle, or 0 if not a cycle.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">IdealFlow.Network</span> <span class="k">as</span> <span class="nn">net</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="n">net</span><span class="o">.</span><span class="n">IFN</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">add_link</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">add_link</span><span class="p">(</span><span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">cycle_sum_weight</span><span class="p">([</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">])</span>
<span class="go">3</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="IdealFlow.Network.IFN.decimal_to_fraction">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">decimal_to_fraction</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">decimal</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tolerance</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">1e-06</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">tuple</span></span></span><a class="headerlink" href="#IdealFlow.Network.IFN.decimal_to_fraction" title="Link to this definition"></a></dt>
<dd><p>Converts a decimal to its closest fraction using a form of the Stern-Brocot tree approach.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>decimal</strong> (<em>float</em>)  The decimal number to convert.</p></li>
<li><p><strong>tolerance</strong> (<em>float</em>)  Precision tolerance. (default: use 6 decimal digits to make it precise)</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The numerator and denominator of the fraction.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>tuple</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">IdealFlow.Network</span> <span class="k">as</span> <span class="nn">net</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="n">net</span><span class="o">.</span><span class="n">IFN</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">decimal_to_fraction</span><span class="p">(</span><span class="mf">0.75</span><span class="p">)</span>
<span class="go">(3, 4)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">decimal_to_fraction</span><span class="p">(</span><span class="mf">0.333333</span><span class="p">)</span>
<span class="go">(1, 3)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">decimal_to_fraction</span><span class="p">(</span><span class="mf">0.111111</span><span class="p">)</span>
<span class="go">(1, 9)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">decimal_to_fraction</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span>
<span class="go">(355, 113)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="IdealFlow.Network.IFN.decompose">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">decompose</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">matrix</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">str</span></span></span><a class="headerlink" href="#IdealFlow.Network.IFN.decompose" title="Link to this definition"></a></dt>
<dd><p>Decompose a ideal flow matrix into a network signature.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>F</strong> (<em>list</em><em> of </em><em>list</em><em> of </em><em>int/float</em>)  The flow matrix.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The decomposed network signature.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>str</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>ValueError</strong>  If F is not an ideal flow matrix.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#IdealFlow.Network.IFN.compose" title="IdealFlow.Network.IFN.compose"><code class="xref py py-meth docutils literal notranslate"><span class="pre">compose()</span></code></a>
<a class="reference internal" href="#IdealFlow.Network.IFN.find_all_cycles_in_matrix" title="IdealFlow.Network.IFN.find_all_cycles_in_matrix"><code class="xref py py-meth docutils literal notranslate"><span class="pre">find_all_cycles_in_matrix()</span></code></a></p>
</div>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">IdealFlow.Network</span> <span class="k">as</span> <span class="nn">net</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="n">net</span><span class="o">.</span><span class="n">IFN</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">F</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">signature</span> <span class="o">=</span> <span class="n">n</span><span class="o">.</span><span class="n">decompose</span><span class="p">(</span><span class="n">F</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">signature</span><span class="p">)</span>
<span class="go">3a + ab</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">F</span><span class="o">=</span><span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">decompose</span><span class="p">(</span><span class="n">F</span><span class="p">)</span>
<span class="go">abc + 2ab</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="IdealFlow.Network.IFN.delete_link">
<span class="sig-name descname"><span class="pre">delete_link</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">startNode</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">endNode</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#IdealFlow.Network.IFN.delete_link" title="Link to this definition"></a></dt>
<dd><p>Deletes a link between two nodes. If the starting node becomes isolated, it is removed.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>startNode</strong> (<em>str</em>)  The starting node.</p></li>
<li><p><strong>endNode</strong> (<em>str</em>)  The ending node.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">IdealFlow.Network</span> <span class="k">as</span> <span class="nn">net</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="n">net</span><span class="o">.</span><span class="n">IFN</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">add_link</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">delete_link</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">get_link_flow</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">))</span>
<span class="go">nan</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="IdealFlow.Network.IFN.delete_node">
<span class="sig-name descname"><span class="pre">delete_node</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">nodeName</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#IdealFlow.Network.IFN.delete_node" title="Link to this definition"></a></dt>
<dd><p>Deletes a node from the network and all connected links.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>node</strong> (<em>str</em>)  The name or identifier of the node to be deleted.</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">IdealFlow.Network</span> <span class="k">as</span> <span class="nn">net</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="n">net</span><span class="o">.</span><span class="n">IFN</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">add_link</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span><span class="s1">&#39;b&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">add_link</span><span class="p">(</span><span class="s1">&#39;c&#39;</span><span class="p">,</span><span class="s1">&#39;b&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">delete_node</span><span class="p">(</span><span class="s1">&#39;b&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="IdealFlow.Network.IFN.density">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">density</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">float</span></em><a class="headerlink" href="#IdealFlow.Network.IFN.density" title="Link to this definition"></a></dt>
<dd><p>Calculate the density of the graph, which is the ratio of the number of edges to the number of possible edges in a complete graph.
It measures how close a given graph is to a complete graph.
The maximal density is 1, if a graph is complete.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The density of the graph.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>float</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">IdealFlow.Network</span> <span class="k">as</span> <span class="nn">net</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="n">net</span><span class="o">.</span><span class="n">IFN</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">add_link</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">add_link</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">density</span>
<span class="go">0.6666666666666666</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="IdealFlow.Network.IFN.dfs">
<span class="sig-name descname"><span class="pre">dfs</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">startNode</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">list</span></span></span><a class="headerlink" href="#IdealFlow.Network.IFN.dfs" title="Link to this definition"></a></dt>
<dd><p>Perform Depth-First Search (DFS) traversal starting from startNode.
This method explores the graph by visiting a node, then recursively visiting its unvisited neighbors.
The traversal continues until all reachable nodes from startNode are visited. It doesnt look for a
specific destination.</p>
<p>Use this method when you want to visit all connected nodes. It will visit nodes until all have been explored (order may vary based on graph structure).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>startNode</strong> (<em>str</em>)  The starting node.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A list of nodes visited during DFS traversal.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>list</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">IdealFlow.Network</span> <span class="k">as</span> <span class="nn">net</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="n">net</span><span class="o">.</span><span class="n">IFN</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">add_link</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">add_link</span><span class="p">(</span><span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">add_link</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;d&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">dfs</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">)</span>
<span class="go">[&#39;a&#39;, &#39;d&#39;, &#39;b&#39;, &#39;c&#39;]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="IdealFlow.Network.IFN.dfs_adj_list">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">dfs_adj_list</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">v</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">start</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">visited</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stack</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">adj_list</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cycles</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nodes</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#IdealFlow.Network.IFN.dfs_adj_list" title="Link to this definition"></a></dt>
<dd><p>Perform DFS to find cycles in the adjacency list.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="IdealFlow.Network.IFN.dfs_until">
<span class="sig-name descname"><span class="pre">dfs_until</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">startNode</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">endNode</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">list</span></span></span><a class="headerlink" href="#IdealFlow.Network.IFN.dfs_until" title="Link to this definition"></a></dt>
<dd><p>Perform Depth-First Search (DFS) traversal starting from startNode until endNode is reached.</p>
<p>This method behaves like DFS but halts as soon as the specified endNode is encountered. Its useful
when you want to find a node but dont need to explore the entire graph.</p>
<p>Use this method when youre looking for a node and want to stop traversal once you find it.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>startNode</strong> (<em>str</em>)  The starting node for the DFS traversal.</p></li>
<li><p><strong>endNode</strong> (<em>str</em>)  The target node at which the traversal stops.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A list of nodes visited during DFS traversal until the endNode is reached.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>list</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">IdealFlow.Network</span> <span class="k">as</span> <span class="nn">net</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="n">net</span><span class="o">.</span><span class="n">IFN</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">add_link</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">add_link</span><span class="p">(</span><span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">add_link</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;d&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">dfs_until</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">)</span>
<span class="go">[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="IdealFlow.Network.IFN.diameter">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">diameter</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">int</span></em><a class="headerlink" href="#IdealFlow.Network.IFN.diameter" title="Link to this definition"></a></dt>
<dd><p>Compute the diameter of the network, which is the longest shortest path between any pair of nodes. The diameter d of a graph is defined as
the maximum eccentricity of any vertex in the graph.
The diameter is the length of the shortest path
between the most distanced nodes.
To determine the diameter of a graph,
first find the shortest path between each pair of vertices.
The greatest length of any of these paths is the diameter of the graph.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The diameter of the network.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>int</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">IdealFlow.Network</span> <span class="k">as</span> <span class="nn">net</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="n">net</span><span class="o">.</span><span class="n">IFN</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">add_link</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">add_link</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">diameter</span>
<span class="go">1</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="IdealFlow.Network.IFN.difference">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">difference</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">net2</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#IdealFlow.Network.IFN" title="IdealFlow.Network.IFN"><span class="pre">IFN</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">net1</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#IdealFlow.Network.IFN" title="IdealFlow.Network.IFN"><span class="pre">IFN</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#IdealFlow.Network.IFN" title="IdealFlow.Network.IFN"><span class="pre">IFN</span></a></span></span><a class="headerlink" href="#IdealFlow.Network.IFN.difference" title="Link to this definition"></a></dt>
<dd><p>Subtract the link flow of net1 from net2.</p>
<p>Reduce link flow of net2 based on net1 = set difference (net2-net1)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>net1</strong> (<a class="reference internal" href="#IdealFlow.Network.IFN" title="IdealFlow.Network.IFN"><em>IFN</em></a>)  The network to subtract. (smaller)</p></li>
<li><p><strong>net2</strong> (<a class="reference internal" href="#IdealFlow.Network.IFN" title="IdealFlow.Network.IFN"><em>IFN</em></a>)  The base network to subtract from.(base - usually larger)</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The updated network after the subtraction.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="#IdealFlow.Network.IFN" title="IdealFlow.Network.IFN">IFN</a></p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">IdealFlow.Network</span> <span class="k">as</span> <span class="nn">net</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="n">net</span><span class="o">.</span><span class="n">IFN</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">base_net</span><span class="p">,</span> <span class="n">diff_net</span> <span class="o">=</span> <span class="n">net</span><span class="o">.</span><span class="n">IFN</span><span class="p">(),</span> <span class="n">net</span><span class="o">.</span><span class="n">IFN</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">result_net</span> <span class="o">=</span> <span class="n">n</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="n">base_net</span><span class="p">,</span> <span class="n">diff_net</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="IdealFlow.Network.IFN.duplicate">
<span class="sig-name descname"><span class="pre">duplicate</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#IdealFlow.Network.IFN" title="IdealFlow.Network.IFN"><span class="pre">IFN</span></a></span></span><a class="headerlink" href="#IdealFlow.Network.IFN.duplicate" title="Link to this definition"></a></dt>
<dd><p>Create a duplicate of the current network.
(not the same reference)</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>A new network that is a deep copy of the current one.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference internal" href="#IdealFlow.Network.IFN" title="IdealFlow.Network.IFN">IFN</a></p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">IdealFlow.Network</span> <span class="k">as</span> <span class="nn">net</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="n">net</span><span class="o">.</span><span class="n">IFN</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">duplicate_net</span> <span class="o">=</span> <span class="n">n</span><span class="o">.</span><span class="n">duplicate</span><span class="p">()</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="IdealFlow.Network.IFN.equivalent_ifn">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">equivalent_ifn</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">F</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">scaling</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">is_rounded</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">ndarray</span></span></span><a class="headerlink" href="#IdealFlow.Network.IFN.equivalent_ifn" title="Link to this definition"></a></dt>
<dd><p>Compute an equivalent ideal flow network with the given scaling.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>F</strong> (<em>np.ndarray</em>)  The flow matrix.</p></li>
<li><p><strong>scaling</strong> (<em>float</em>)  The scaling factor.</p></li>
<li><p><strong>is_rounded</strong> (<em>bool</em>)  Whether to round the result. Default is False.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The equivalent ideal flow matrix.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>np.ndarray</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">IdealFlow.Network</span> <span class="k">as</span> <span class="nn">net</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="n">net</span><span class="o">.</span><span class="n">IFN</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">F</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.4</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">scaled_F</span> <span class="o">=</span> <span class="n">n</span><span class="o">.</span><span class="n">equivalent_ifn</span><span class="p">(</span><span class="n">F</span><span class="p">,</span> <span class="n">scaling</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">scaled_F</span><span class="p">)</span>
<span class="go">[[0.4 0.6]</span>
<span class="go"> [0.8 0.2]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="IdealFlow.Network.IFN.excel_col_to_num">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">excel_col_to_num</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">col</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">int</span></span></span><a class="headerlink" href="#IdealFlow.Network.IFN.excel_col_to_num" title="Link to this definition"></a></dt>
<dd><p>Convert an Excel-style column label to a number.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>col</strong> (<em>str</em>)  The column label (e.g., a, aa).</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The corresponding number.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>int</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>ValueError</strong>  If the column contains non-alphabetic characters.</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">IdealFlow.Network</span> <span class="k">as</span> <span class="nn">net</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="n">net</span><span class="o">.</span><span class="n">IFN</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">excel_col_to_num</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">)</span>
<span class="go">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">excel_col_to_num</span><span class="p">(</span><span class="s1">&#39;aa&#39;</span><span class="p">)</span>
<span class="go">27</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="IdealFlow.Network.IFN.extract_first_k_terms">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">extract_first_k_terms</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">cycle_str</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">k</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">str</span></span></span><a class="headerlink" href="#IdealFlow.Network.IFN.extract_first_k_terms" title="Link to this definition"></a></dt>
<dd><p>Extracts the first k terms from a cycle string.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>cycle_str</strong> (<em>str</em>)  The cycle string with terms separated by  + .</p></li>
<li><p><strong>k</strong> (<em>int</em>)  The number of terms to extract.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A new cycle string with the first k terms.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>str</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">IdealFlow.Network</span> <span class="k">as</span> <span class="nn">net</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="n">net</span><span class="o">.</span><span class="n">IFN</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">extract_first_k_terms</span><span class="p">(</span><span class="s1">&#39;a + b + c + d&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="go">&#39;a + b&#39;</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="IdealFlow.Network.IFN.extract_last_k_terms">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">extract_last_k_terms</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">cycle_str</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">k</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">str</span></span></span><a class="headerlink" href="#IdealFlow.Network.IFN.extract_last_k_terms" title="Link to this definition"></a></dt>
<dd><p>Extracts the last k terms from a cycle string.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>cycle_str</strong> (<em>str</em>)  The cycle string with terms separated by  + .</p></li>
<li><p><strong>k</strong> (<em>int</em>)  The number of terms to extract.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A new cycle string with the last k terms.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>str</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">IdealFlow.Network</span> <span class="k">as</span> <span class="nn">net</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="n">net</span><span class="o">.</span><span class="n">IFN</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">extract_last_k_terms</span><span class="p">(</span><span class="s1">&#39;a + b + c + d&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="go">&#39;c + d&#39;</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="IdealFlow.Network.IFN.find_a_cycle">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">find_a_cycle</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">start_node</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">target_node</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">adjL</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">dict</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">str</span></span></span><a class="headerlink" href="#IdealFlow.Network.IFN.find_a_cycle" title="Link to this definition"></a></dt>
<dd><p>Find a cycle in the adjacency list starting from a given node.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>start_node</strong> (<em>str</em>)  The starting node.</p></li>
<li><p><strong>target_node</strong> (<em>str</em>)  The target node to find the cycle.</p></li>
<li><p><strong>adjL</strong> (<em>dict</em>)  The adjacency list, where keys are nodes and values are dictionaries of neighbors.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The cycle found as a string, or None if no cycle is found.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>str</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">IdealFlow.Network</span> <span class="k">as</span> <span class="nn">net</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="n">net</span><span class="o">.</span><span class="n">IFN</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">adjL</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;a&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;b&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">},</span> <span class="s1">&#39;b&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;a&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">},</span> <span class="s1">&#39;c&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;b&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">}}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">find_a_cycle</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">,</span> <span class="n">adjL</span><span class="p">)</span>
<span class="go">&#39;abc&#39;</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="IdealFlow.Network.IFN.find_all_cycles_in_adj_list">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">find_all_cycles_in_adj_list</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">adjL</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">dict</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">list</span></span></span><a class="headerlink" href="#IdealFlow.Network.IFN.find_all_cycles_in_adj_list" title="Link to this definition"></a></dt>
<dd><p>Find all cycles in a given adjacency list.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>adjL</strong> (<em>dict</em>)  The adjacency list.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The list of cycles found in the adjacency list.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>list of str</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">IdealFlow.Network</span> <span class="k">as</span> <span class="nn">net</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="n">net</span><span class="o">.</span><span class="n">IFN</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">adjL</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;a&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;b&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">},</span> <span class="s1">&#39;b&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;c&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">},</span> <span class="s1">&#39;c&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;a&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">}}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cycles</span> <span class="o">=</span> <span class="n">n</span><span class="o">.</span><span class="n">find_all_cycles_in_adj_list</span><span class="p">(</span><span class="n">adjL</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">cycles</span><span class="p">)</span>
<span class="go">[(&#39;a&#39;, &#39;b&#39;, &#39;c&#39;)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">adj_list</span><span class="o">=</span><span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="p">{</span><span class="mi">1</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span> <span class="mi">1</span><span class="p">:</span> <span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">:</span> <span class="mi">1</span><span class="p">},</span> <span class="mi">2</span><span class="p">:</span> <span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="mi">1</span><span class="p">}}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">find_all_cycles_in_adj_list</span><span class="p">(</span><span class="n">adj_list</span><span class="p">)</span>
<span class="go">[(0, 1), (0, 1, 2)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">adjL</span><span class="o">=</span><span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span> <span class="mi">1</span><span class="p">},</span> <span class="mi">1</span><span class="p">:</span> <span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="mi">1</span><span class="p">}}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">find_all_cycles_in_adj_list</span><span class="p">(</span><span class="n">adjL</span><span class="p">)</span>
<span class="go">[(0,), (0, 1)]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="IdealFlow.Network.IFN.find_all_cycles_in_matrix">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">find_all_cycles_in_matrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">matrix</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">list</span></span></span><a class="headerlink" href="#IdealFlow.Network.IFN.find_all_cycles_in_matrix" title="Link to this definition"></a></dt>
<dd><p>Return list of all possible cycles from the weighted adjacency matrix as cycle terms.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>matrix</strong> (<em>list</em><em> of </em><em>list</em><em> of </em><em>int/float</em>)  The input matrix.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A list of cycles terms found in the matrix.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>list of tuple of str</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#IdealFlow.Network.IFN.find_all_cycles_in_adj_list" title="IdealFlow.Network.IFN.find_all_cycles_in_adj_list"><code class="xref py py-meth docutils literal notranslate"><span class="pre">find_all_cycles_in_adj_list()</span></code></a></p>
</div>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">IdealFlow.Network</span> <span class="k">as</span> <span class="nn">net</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="n">net</span><span class="o">.</span><span class="n">IFN</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">matrix</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">],[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">find_all_cycles_in_matrix</span><span class="p">(</span><span class="n">matrix</span><span class="p">)</span>
<span class="go">[&#39;ab&#39;, &#39;abc&#39;]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="IdealFlow.Network.IFN.find_all_paths">
<span class="sig-name descname"><span class="pre">find_all_paths</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">startNode</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">endNode</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">path</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">[]</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">list</span></span></span><a class="headerlink" href="#IdealFlow.Network.IFN.find_all_paths" title="Link to this definition"></a></dt>
<dd><p>Find all possible paths from the startNode to the endNode.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>startNode</strong> (<em>str</em>)  The starting node.</p></li>
<li><p><strong>endNode</strong> (<em>str</em>)  The target node.</p></li>
<li><p><strong>path</strong> (<em>list</em>)  The current path (used for recursion).</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A list of all possible paths from startNode to endNode.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>list</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">IdealFlow.Network</span> <span class="k">as</span> <span class="nn">net</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="n">net</span><span class="o">.</span><span class="n">IFN</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">add_link</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">add_link</span><span class="p">(</span><span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">find_all_paths</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">)</span>
<span class="go">[[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="IdealFlow.Network.IFN.find_all_permutation_cycles">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">find_all_permutation_cycles</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">matrix</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">set</span></span></span><a class="headerlink" href="#IdealFlow.Network.IFN.find_all_permutation_cycles" title="Link to this definition"></a></dt>
<dd><p>List all cycles in the adjacency matrix as strings, considering all permutations of cycles.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>matrix</strong> (<em>list</em><em> of </em><em>list</em><em> of </em><em>int/float</em>)  The adjacency matrix of the graph.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A set of cycles as strings.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>set</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">IdealFlow.Network</span> <span class="k">as</span> <span class="nn">net</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="n">net</span><span class="o">.</span><span class="n">IFN</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">matrix</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">find_all_permutation_cycles</span><span class="p">(</span><span class="n">matrix</span><span class="p">)</span>
<span class="go">{&#39;ab&#39;, &#39;ba&#39;}</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="IdealFlow.Network.IFN.find_all_walks_in_matrix">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">find_all_walks_in_matrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">matrix</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">list</span></span></span><a class="headerlink" href="#IdealFlow.Network.IFN.find_all_walks_in_matrix" title="Link to this definition"></a></dt>
<dd><p>Find all walks in a given matrix.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>matrix</strong> (<em>list</em><em> of </em><em>list</em><em> of </em><em>int/float</em>)  The input matrix.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A list of walks found in the matrix.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>list of str</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">IdealFlow.Network</span> <span class="k">as</span> <span class="nn">net</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="n">net</span><span class="o">.</span><span class="n">IFN</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">matrix</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">walks</span> <span class="o">=</span> <span class="n">n</span><span class="o">.</span><span class="n">find_all_walks_in_matrix</span><span class="p">(</span><span class="n">matrix</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">walks</span><span class="p">)</span>  <span class="c1"># Output: [&#39;ab&#39;]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="IdealFlow.Network.IFN.find_cardinal_ifn_signature_exhaustive">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">find_cardinal_ifn_signature_exhaustive</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">A</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">str</span></span></span><a class="headerlink" href="#IdealFlow.Network.IFN.find_cardinal_ifn_signature_exhaustive" title="Link to this definition"></a></dt>
<dd><p>Find the cardinal IFN signature using exhaustive search.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>A</strong> (<em>list</em><em> of </em><em>list</em><em> of </em><em>float</em>)  The input matrix representing the flow between nodes.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The cardinal IFN signature.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>str</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">IdealFlow.Network</span> <span class="k">as</span> <span class="nn">net</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="n">net</span><span class="o">.</span><span class="n">IFN</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">find_cardinal_ifn_signature_exhaustive</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="go">&#39;abc&#39;</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="IdealFlow.Network.IFN.find_cycles">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">find_cycles</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">matrix</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">list</span></span></span><a class="headerlink" href="#IdealFlow.Network.IFN.find_cycles" title="Link to this definition"></a></dt>
<dd><p>Finds all cycles in a given adjacency matrix and returns them in canonical form.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>matrix</strong> (<em>list</em><em> of </em><em>list</em>)  Adjacency matrix representing the digraph.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>List of unique cycles in canonical form.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>list</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">IdealFlow.Network</span> <span class="k">as</span> <span class="nn">net</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="n">net</span><span class="o">.</span><span class="n">IFN</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">matrix</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">find_cycles</span><span class="p">(</span><span class="n">matrix</span><span class="p">)</span>
<span class="go">[&#39;ab&#39;]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="IdealFlow.Network.IFN.find_element_in_list">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">find_element_in_list</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">element</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">list_element</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">list</span></span></span><a class="headerlink" href="#IdealFlow.Network.IFN.find_element_in_list" title="Link to this definition"></a></dt>
<dd><p>Find all indices of an element in a list.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>element</strong>  The element to find.</p></li>
<li><p><strong>list_element</strong> (<em>list</em>)  The list to search in.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>List of indices where the element is found.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>list</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">IdealFlow.Network</span> <span class="k">as</span> <span class="nn">net</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="n">net</span><span class="o">.</span><span class="n">IFN</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">find_element_in_list</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
<span class="go">[0, 2]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="IdealFlow.Network.IFN.find_key_in_dict">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">find_key_in_dict</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">val</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dic</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">dict</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">str</span></span></span><a class="headerlink" href="#IdealFlow.Network.IFN.find_key_in_dict" title="Link to this definition"></a></dt>
<dd><p>Find the first key in a dictionary that matches a given value.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>val</strong>  The value to search for.</p></li>
<li><p><strong>dic</strong> (<em>dict</em>)  The dictionary to search in.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The key corresponding to the given value, or <cite>None</cite> if not found.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>str</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">IdealFlow.Network</span> <span class="k">as</span> <span class="nn">net</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="n">net</span><span class="o">.</span><span class="n">IFN</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;a&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">find_key_in_dict</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">d</span><span class="p">)</span>
<span class="go">&#39;b&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">find_key_in_dict</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;a&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;e&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">})</span>
<span class="go">&#39;e&#39;</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="IdealFlow.Network.IFN.find_path">
<span class="sig-name descname"><span class="pre">find_path</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">startNode</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">endNode</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">path</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">[]</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">list</span></span></span><a class="headerlink" href="#IdealFlow.Network.IFN.find_path" title="Link to this definition"></a></dt>
<dd><p>Find a path from the startNode to the endNode using Depth First Search (DFS).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>startNode</strong> (<em>str</em>)  The starting node.</p></li>
<li><p><strong>endNode</strong> (<em>str</em>)  The target node.</p></li>
<li><p><strong>path</strong> (<em>list</em>)  The current path (used for recursion).</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A list of nodes representing the path from startNode to endNode.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>list</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">IdealFlow.Network</span> <span class="k">as</span> <span class="nn">net</span>     <span class="c1"># import package.module as alias</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="n">net</span><span class="o">.</span><span class="n">IFN</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">add_link</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">add_link</span><span class="p">(</span><span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">find_path</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">)</span>
<span class="go">[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#IdealFlow.Network.IFN.get_path" title="IdealFlow.Network.IFN.get_path"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get_path()</span></code></a></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="IdealFlow.Network.IFN.find_path_cycle_limit">
<span class="sig-name descname"><span class="pre">find_path_cycle_limit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">startNode</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">endNode</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_internal_cycle</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">visited_nodes</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">node_visit_counts</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">path</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#IdealFlow.Network.IFN.find_path_cycle_limit" title="Link to this definition"></a></dt>
<dd><p>Find a path from startNode to endNode using DFS with backtracking, limiting the number of internal cycles.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>startNode</strong> (<em>str</em>)  The starting node.</p></li>
<li><p><strong>endNode</strong> (<em>str</em>)  The target node.</p></li>
<li><p><strong>max_internal_cycle</strong> (<em>int</em>)  The maximum number of internal cycles allowed.</p></li>
<li><p><strong>visited_nodes</strong> (<em>set</em>)  The set of nodes already visited in the overall path.</p></li>
<li><p><strong>node_visit_counts</strong> (<em>dict</em>)  Dictionary of node visit counts in the current recursive path.</p></li>
<li><p><strong>path</strong> (<em>list</em>)  The current path.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A list of nodes forming the path from startNode to endNode.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>list</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="IdealFlow.Network.IFN.find_pivot_type">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">find_pivot_type</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">cycle1</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cycle2</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">str</span></span></span><a class="headerlink" href="#IdealFlow.Network.IFN.find_pivot_type" title="Link to this definition"></a></dt>
<dd><p>Determine the type of pivot (common node or path) between two cycles.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>cycle1</strong> (<em>str</em>)  The first cycle.</p></li>
<li><p><strong>cycle2</strong> (<em>str</em>)  The second cycle.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The type of pivot (node, link or path).</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>str</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">IdealFlow.Network</span> <span class="k">as</span> <span class="nn">net</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="n">net</span><span class="o">.</span><span class="n">IFN</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cycle1</span> <span class="o">=</span> <span class="s2">&quot;abc&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cycle2</span> <span class="o">=</span> <span class="s2">&quot;bcd&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">result</span> <span class="o">=</span> <span class="n">n</span><span class="o">.</span><span class="n">find_pivot_type</span><span class="p">(</span><span class="n">cycle1</span><span class="p">,</span> <span class="n">cycle2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>  <span class="c1"># Output: &#39;link: bc&#39;</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="IdealFlow.Network.IFN.find_pivots">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">find_pivots</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">signature</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">list</span></span></span><a class="headerlink" href="#IdealFlow.Network.IFN.find_pivots" title="Link to this definition"></a></dt>
<dd><p>Find pivots in a network signature, which are common nodes between cycles.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>signature</strong> (<em>str</em>)  The network signature.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A list of pivots between cycles.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>list of dict</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">IdealFlow.Network</span> <span class="k">as</span> <span class="nn">net</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="n">net</span><span class="o">.</span><span class="n">IFN</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">signature</span> <span class="o">=</span> <span class="s2">&quot;abc + bcd + cde&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pivots</span> <span class="o">=</span> <span class="n">n</span><span class="o">.</span><span class="n">find_pivots</span><span class="p">(</span><span class="n">signature</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">pivots</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="IdealFlow.Network.IFN.flow_matrix_to_adj_list">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">flow_matrix_to_adj_list</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">F</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">dict</span></span></span><a class="headerlink" href="#IdealFlow.Network.IFN.flow_matrix_to_adj_list" title="Link to this definition"></a></dt>
<dd><p>Convert a flow matrix to an adjacency list.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>F</strong> (<em>list</em><em> of </em><em>list</em><em> of </em><em>int/float</em>)  The flow matrix.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The adjacency list representation of the flow matrix.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>dict</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">IdealFlow.Network</span> <span class="k">as</span> <span class="nn">net</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="n">net</span><span class="o">.</span><span class="n">IFN</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">F</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">adj_list</span> <span class="o">=</span> <span class="n">n</span><span class="o">.</span><span class="n">flow_matrix_to_adj_list</span><span class="p">(</span><span class="n">F</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">adj_list</span><span class="p">)</span>
<span class="go">{0: {0: 3, 1: 1}, 1: {0: 1}}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">F</span><span class="o">=</span><span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">flow_matrix_to_adj_list</span><span class="p">(</span><span class="n">F</span><span class="p">)</span>
<span class="go">{0: {1: 3}, 1: {0: 2, 2: 1}, 2: {0: 1}}</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="IdealFlow.Network.IFN.flows_in_cycle">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">flows_in_cycle</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">F</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cycle</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">tuple</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">list</span></span></span><a class="headerlink" href="#IdealFlow.Network.IFN.flows_in_cycle" title="Link to this definition"></a></dt>
<dd><p>Return list of flows in a cycle.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>F</strong> (<em>list</em>)  The flow matrix.</p></li>
<li><p><strong>cycle</strong> (<em>tuple</em><em> or </em><em>string</em>)  tuple of indices in a cycle or string cycle term</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The list of flows in the cycle.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>list</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#IdealFlow.Network.IFN.change_flow_in_cycle" title="IdealFlow.Network.IFN.change_flow_in_cycle"><code class="xref py py-meth docutils literal notranslate"><span class="pre">change_flow_in_cycle()</span></code></a></p>
</div>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">IdealFlow.Network</span> <span class="k">as</span> <span class="nn">net</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="n">net</span><span class="o">.</span><span class="n">IFN</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">F</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
<span class="go">         [1, 0]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">adjL</span><span class="o">=</span><span class="n">n</span><span class="o">.</span><span class="n">flow_matrix_to_adj_list</span><span class="p">(</span><span class="n">F</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">find_all_cycles_in_adj_list</span><span class="p">(</span><span class="n">adjL</span><span class="p">)</span>
<span class="go">[(0,), (0, 1)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cycle</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">flows_in_cycle</span><span class="p">(</span><span class="n">F</span><span class="p">,</span><span class="n">cycle</span><span class="p">)</span>
<span class="go">[1, 1]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cycle</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">flows_in_cycle</span><span class="p">(</span><span class="n">F</span><span class="p">,</span><span class="n">cycle</span><span class="p">)</span>
<span class="go">[3]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">F</span><span class="o">=</span><span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="go">       [2, 0, 1],</span>
<span class="go">       [1, 0, 0]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">adjL</span><span class="o">=</span><span class="n">n</span><span class="o">.</span><span class="n">flow_matrix_to_adj_list</span><span class="p">(</span><span class="n">F</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">find_all_cycles_in_adj_list</span><span class="p">(</span><span class="n">adjL</span><span class="p">)</span>
<span class="go">[(0, 1), (0, 1, 2)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cycle</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">flows_in_cycle</span><span class="p">(</span><span class="n">F</span><span class="p">,</span><span class="n">cycle</span><span class="p">)</span>
<span class="go">[3, 2]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cycle</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">flows_in_cycle</span><span class="p">(</span><span class="n">F</span><span class="p">,</span><span class="n">cycle</span><span class="p">)</span>
<span class="go">[3, 1, 1]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cycles</span><span class="o">=</span><span class="n">n</span><span class="o">.</span><span class="n">find_all_cycles_in_matrix</span><span class="p">(</span><span class="n">F</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">cycles</span><span class="p">)</span>
<span class="go">[(&#39;a&#39;, &#39;b&#39;, &#39;c&#39;), (&#39;a&#39;, &#39;b&#39;)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">flows_in_cycle</span><span class="p">(</span><span class="n">F</span><span class="p">,</span><span class="n">cycle</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="go">[3, 1, 1]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">flows_in_cycle</span><span class="p">(</span><span class="n">F</span><span class="p">,</span><span class="n">cycle</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
<span class="go">[3, 2]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="IdealFlow.Network.IFN.form_link_cycle_matrix">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">form_link_cycle_matrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">F</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">tuple</span></span></span><a class="headerlink" href="#IdealFlow.Network.IFN.form_link_cycle_matrix" title="Link to this definition"></a></dt>
<dd><p>Forms the link-cycle matrix H and the link flow vector y.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>F</strong> (<em>np.ndarray</em>)  Flow matrix representing the network.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><dl class="simple">
<dt>A tuple containing the link-cycle matrix H, the link flow vector y,</dt><dd><p>a list of cycles, and a list of links.</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>tuple</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">IdealFlow.Network</span> <span class="k">as</span> <span class="nn">net</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="n">net</span><span class="o">.</span><span class="n">IFN</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">F</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">H</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">cycles</span><span class="p">,</span> <span class="n">links</span> <span class="o">=</span> <span class="n">n</span><span class="o">.</span><span class="n">form_link_cycle_matrix</span><span class="p">(</span><span class="n">F</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="IdealFlow.Network.IFN.from_base62">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">from_base62</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">s</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">int</span></span></span><a class="headerlink" href="#IdealFlow.Network.IFN.from_base62" title="Link to this definition"></a></dt>
<dd><p>Convert a base62 string to a integer number.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>s</strong> (<em>str</em>)  The base62 string.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The corresponding number.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>int</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>ValueError</strong>  If the string contains invalid base62 characters.</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">IdealFlow.Network</span> <span class="k">as</span> <span class="nn">net</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="n">net</span><span class="o">.</span><span class="n">IFN</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">from_base62</span><span class="p">(</span><span class="s1">&#39;0&#39;</span><span class="p">)</span>
<span class="go">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">from_base62</span><span class="p">(</span><span class="s1">&#39;A&#39;</span><span class="p">)</span>
<span class="go">36</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">from_base62</span><span class="p">(</span><span class="s1">&#39;10&#39;</span><span class="p">)</span>
<span class="go">62</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="IdealFlow.Network.IFN.generate">
<span class="sig-name descname"><span class="pre">generate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">startNode</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">is_cycle</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">allow_internal_cycles</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_internal_cycles</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">inf</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">list</span></span></span><a class="headerlink" href="#IdealFlow.Network.IFN.generate" title="Link to this definition"></a></dt>
<dd><p>Generate a random walk or random cycle starting and ending at the specified cloud node.</p>
<dl class="simple">
<dt>Internal Cycle Handling:</dt><dd><p>If <cite>allow_internal_cycles</cite> is False, the walk will terminate upon revisiting any node.
If <cite>allow_internal_cycles</cite> is True, the walk can revisit nodes, but the number of internal cycles is limited by <cite>max_internal_cycles</cite>.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>startNode</strong> (<em>str</em>)  The starting node from which the random cycle is generated. Default is self.cloud_name.</p></li>
<li><p><strong>is_cycle</strong> (<em>bool</em>)  technique to generate whether random walk or random cycle. Default is True (i.e. random cycle)</p></li>
<li><p><strong>allow_internal_cycles</strong> (<em>bool</em>)  Whether to allow internal cycles (revisiting nodes) during the walk. Defaults to False.</p></li>
<li><p><strong>max_internal_cycles</strong> (<em>int</em>)  The maximum number of internal cycles allowed. Defaults to infinity.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A list of nodes representing the random cycle.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>list</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">IdealFlow.Network</span> <span class="k">as</span> <span class="nn">net</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="n">net</span><span class="o">.</span><span class="n">IFN</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">trajectory</span> <span class="o">=</span>  <span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span><span class="s1">&#39;b&#39;</span><span class="p">,</span><span class="s1">&#39;c&#39;</span><span class="p">,</span><span class="s1">&#39;d&#39;</span><span class="p">,</span><span class="s1">&#39;e&#39;</span><span class="p">,</span><span class="s1">&#39;a&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">assign</span><span class="p">(</span><span class="n">trajectory</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">generate</span><span class="p">(</span><span class="s1">&#39;b&#39;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="IdealFlow.Network.IFN.generate_combinations">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">generate_combinations</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">elements</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">list</span></span></span><a class="headerlink" href="#IdealFlow.Network.IFN.generate_combinations" title="Link to this definition"></a></dt>
<dd><p>Generates all combinations of a given list of elements.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>elements</strong> (<em>list</em>)  The list of elements.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The list of combinations.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>list of list</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">IdealFlow.Network</span> <span class="k">as</span> <span class="nn">net</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="n">net</span><span class="o">.</span><span class="n">IFN</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">generate_combinations</span><span class="p">([</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">])</span>
<span class="go">[[&#39;a&#39;], [&#39;a&#39;, &#39;b&#39;], [&#39;b&#39;]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">generate_combinations</span><span class="p">([</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">])</span>
<span class="go">[[&#39;a&#39;], [&#39;a&#39;, &#39;b&#39;], [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;], [&#39;a&#39;, &#39;c&#39;], [&#39;b&#39;], [&#39;b&#39;, &#39;c&#39;], [&#39;c&#39;]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="IdealFlow.Network.IFN.generate_random_terms">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">generate_random_terms</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">cycle_dict</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">dict</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">k</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">is_premier</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">str</span></span></span><a class="headerlink" href="#IdealFlow.Network.IFN.generate_random_terms" title="Link to this definition"></a></dt>
<dd><p>Generates a random cycle string with k terms selected from the given cycle dictionary.
Optionally, assigns random coefficients to the terms.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>cycle_dict</strong> (<em>dict</em>)  A dictionary of cycle terms and their coefficients.</p></li>
<li><p><strong>k</strong> (<em>int</em>)  The number of terms to generate.</p></li>
<li><p><strong>is_premier</strong> (<em>bool</em><em>, </em><em>optional</em>)  If True, returns terms without random coefficients.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A new cycle string with k randomly selected terms.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>str</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">IdealFlow.Network</span> <span class="k">as</span> <span class="nn">net</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="n">net</span><span class="o">.</span><span class="n">IFN</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cycle_dict</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;a&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">generate_random_terms</span><span class="p">(</span><span class="n">cycle_dict</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="go">&#39;2a + 1b&#39;</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="IdealFlow.Network.IFN.get_data">
<span class="sig-name descname"><span class="pre">get_data</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#IdealFlow.Network.IFN.get_data" title="Link to this definition"></a></dt>
<dd><p>Property to return the internal data structure of adjacency list</p>
<p>Example:
&gt;&gt;&gt; import IdealFlow.Network as net
&gt;&gt;&gt; n = net.IFN()
&gt;&gt;&gt; adjList = {a: {b: 1, c: 3}, b: {c:2}, c: {a:5}}
&gt;&gt;&gt; n.set_data(adjList)
&gt;&gt;&gt; n.get_data()
{a: {b: 1, c: 3}, b: {c:2}, c: {a:5}}</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="IdealFlow.Network.IFN.get_link_flow">
<span class="sig-name descname"><span class="pre">get_link_flow</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">startNode</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">endNode</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">float</span></span></span><a class="headerlink" href="#IdealFlow.Network.IFN.get_link_flow" title="Link to this definition"></a></dt>
<dd><p>Returns the flow of a link between two nodes.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>startNode</strong> (<em>str</em>)  The starting node.</p></li>
<li><p><strong>endNode</strong> (<em>str</em>)  The ending node.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The flow of the link, or NaN if the link does not exist.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">IdealFlow.Network</span> <span class="k">as</span> <span class="nn">net</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="n">net</span><span class="o">.</span><span class="n">IFN</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">add_link</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">get_link_flow</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">))</span>
<span class="go">2.0</span>
</pre></div>
</div>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="IdealFlow.Network.IFN.get_links">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">get_links</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">list</span></em><a class="headerlink" href="#IdealFlow.Network.IFN.get_links" title="Link to this definition"></a></dt>
<dd><p>Returns the list of links in the network.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>A list of links, where each link is represented as [startNode, endNode].</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>list</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">IdealFlow.Network</span> <span class="k">as</span> <span class="nn">net</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="n">net</span><span class="o">.</span><span class="n">IFN</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">add_link</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">get_links</span><span class="p">)</span>
<span class="go">[[&#39;a&#39;, &#39;b&#39;]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="IdealFlow.Network.IFN.get_matrix">
<span class="sig-name descname"><span class="pre">get_matrix</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">tuple</span></span></span><a class="headerlink" href="#IdealFlow.Network.IFN.get_matrix" title="Link to this definition"></a></dt>
<dd><p>Return the adjacency matrix of the network and the list of nodes.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>A tuple containing the adjacency matrix and list of nodes.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>tuple</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">IdealFlow.Network</span> <span class="k">as</span> <span class="nn">net</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="n">net</span><span class="o">.</span><span class="n">IFN</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">adj_matrix</span><span class="p">,</span> <span class="n">nodes</span> <span class="o">=</span> <span class="n">n</span><span class="o">.</span><span class="n">get_matrix</span><span class="p">()</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="IdealFlow.Network.IFN.get_path">
<span class="sig-name descname"><span class="pre">get_path</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">startNode</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">endNode</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">list</span></span></span><a class="headerlink" href="#IdealFlow.Network.IFN.get_path" title="Link to this definition"></a></dt>
<dd><p>return a path from the startNode to the endNode if exists.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="IdealFlow.Network.IFN.get_path_entropy">
<span class="sig-name descname"><span class="pre">get_path_entropy</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">trajectory</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">isUpdateFirst</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">float</span></span></span><a class="headerlink" href="#IdealFlow.Network.IFN.get_path_entropy" title="Link to this definition"></a></dt>
<dd><p>Calculate the entropy of a given trajectory (path).</p>
<p>If the network probability was not computed, it will update the probabilities before calculation.
The link probability must be greater than zero to be included in entropy computation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>trajectory</strong> (<em>list</em>)  A sequence of nodes forming a path.</p></li>
<li><p><strong>isUpdateFirst</strong> (<em>bool</em>)  Whether to update the network probability before calculation. Defaults to False.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The entropy of the path.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">IdealFlow.Network</span> <span class="k">as</span> <span class="nn">net</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="n">net</span><span class="o">.</span><span class="n">IFN</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">add_link</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">add_link</span><span class="p">(</span><span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">get_path_entropy</span><span class="p">([</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">])</span>
<span class="go">0.9182958340544896</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="IdealFlow.Network.IFN.get_path_probability">
<span class="sig-name descname"><span class="pre">get_path_probability</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">trajectory</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">isUpdateFirst</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">tuple</span></span></span><a class="headerlink" href="#IdealFlow.Network.IFN.get_path_probability" title="Link to this definition"></a></dt>
<dd><p>Compute the average probability of traversing the given trajectory (path) and the number of links.</p>
<p>The traverse will end when it reaches the first zero flow link.
If trajectory has no path, avg prob = 0.
If the network probability was not computed, it will update the probabilities before calculation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>trajectory</strong> (<em>list</em>)  A sequence of nodes forming a path.</p></li>
<li><p><strong>isUpdateFirst</strong> (<em>bool</em>)  Whether to update the network probability before calculation. Defaults to False.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><dl class="simple">
<dt>A tuple containing:</dt><dd><ul class="simple">
<li><p>avg_prob (float): The average probability of traversing the path.</p></li>
<li><p>num_links (int): The number of links traversed in the path.</p></li>
</ul>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>tuple</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">IdealFlow.Network</span> <span class="k">as</span> <span class="nn">net</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="n">net</span><span class="o">.</span><span class="n">IFN</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">add_link</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">add_link</span><span class="p">(</span><span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">get_path_probability</span><span class="p">([</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">])</span>
<span class="go">(0.5, 2)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="IdealFlow.Network.IFN.global_scaling">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">global_scaling</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">F</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">scaling_type</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">'min'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">val</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">float</span></span></span><a class="headerlink" href="#IdealFlow.Network.IFN.global_scaling" title="Link to this definition"></a></dt>
<dd><p>Compute a global scaling factor for a flow matrix.
Return scaling factor to ideal flow matrix to get equivalent IFN</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>F</strong> (<em>np.ndarray</em>)  The ideal flow matrix.</p></li>
<li><p><strong>scaling_type</strong> (<em>str</em>)  The type of scaling (min, max, sum, int, avg, std, cov). int means basis IFN (minimum integer)</p></li>
<li><p><strong>val</strong> (<em>float</em>)  The value for scaling. Default is 1.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The scaling factor.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">IdealFlow.Network</span> <span class="k">as</span> <span class="nn">net</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="n">net</span><span class="o">.</span><span class="n">IFN</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">F</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.4</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">scaling</span> <span class="o">=</span> <span class="n">n</span><span class="o">.</span><span class="n">global_scaling</span><span class="p">(</span><span class="n">F</span><span class="p">,</span> <span class="s1">&#39;min&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">scaling</span><span class="p">)</span>
<span class="go">5.0</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="IdealFlow.Network.IFN.hadamard_division">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">hadamard_division</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">ndarray</span></span></span><a class="headerlink" href="#IdealFlow.Network.IFN.hadamard_division" title="Link to this definition"></a></dt>
<dd><p>Perform elementwise division of two matrices, ignoring division by zero.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>a</strong> (<em>np.ndarray</em>)  The numerator matrix.</p></li>
<li><p><strong>b</strong> (<em>np.ndarray</em>)  The denominator matrix.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The result of the elementwise division. Zero is returned for divisions by zero.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>np.ndarray</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">IdealFlow.Network</span> <span class="k">as</span> <span class="nn">net</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="n">net</span><span class="o">.</span><span class="n">IFN</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">B</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">result</span> <span class="o">=</span> <span class="n">n</span><span class="o">.</span><span class="n">hadamard_division</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
<span class="go">[[0.5 1. ]</span>
<span class="go"> [0.  0. ]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="IdealFlow.Network.IFN.has_pivot">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">has_pivot</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">cycle1</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cycle2</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="headerlink" href="#IdealFlow.Network.IFN.has_pivot" title="Link to this definition"></a></dt>
<dd><p>Check if two cycles have a pivot (shared node or link, or path).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>cycle1</strong> (<em>str</em>)  The first cycle.</p></li>
<li><p><strong>cycle2</strong> (<em>str</em>)  The second cycle.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>True if there is a pivot, otherwise False.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>bool</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">IdealFlow.Network</span> <span class="k">as</span> <span class="nn">net</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="n">net</span><span class="o">.</span><span class="n">IFN</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cycle1</span> <span class="o">=</span> <span class="s2">&quot;abc&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cycle2</span> <span class="o">=</span> <span class="s2">&quot;bcd&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">result</span> <span class="o">=</span> <span class="n">n</span><span class="o">.</span><span class="n">has_pivot</span><span class="p">(</span><span class="n">cycle1</span><span class="p">,</span> <span class="n">cycle2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>  <span class="c1"># Output: True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="IdealFlow.Network.IFN.ideal_flow">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">ideal_flow</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">S</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pi</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">ndarray</span></span></span><a class="headerlink" href="#IdealFlow.Network.IFN.ideal_flow" title="Link to this definition"></a></dt>
<dd><p>Compute the ideal flow matrix from a stochastic matrix and Perron vector.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>S</strong> (<em>np.ndarray</em>)  The stochastic matrix.</p></li>
<li><p><strong>pi</strong> (<em>np.ndarray</em>)  The Perron vector.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The ideal flow matrix.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>np.ndarray</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">IdealFlow.Network</span> <span class="k">as</span> <span class="nn">net</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="n">net</span><span class="o">.</span><span class="n">IFN</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">S</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">0.5</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.5</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">F</span> <span class="o">=</span> <span class="n">n</span><span class="o">.</span><span class="n">ideal_flow</span><span class="p">(</span><span class="n">S</span><span class="p">,</span> <span class="n">pi</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">F</span><span class="p">)</span>
<span class="go">[[0.25 0.25]</span>
<span class="go"> [0.25 0.25]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="IdealFlow.Network.IFN.ideal_flow_to_stochastic">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">ideal_flow_to_stochastic</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">F</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">ndarray</span></span></span><a class="headerlink" href="#IdealFlow.Network.IFN.ideal_flow_to_stochastic" title="Link to this definition"></a></dt>
<dd><p>Convert an ideal flow matrix into a Markov stochastic matrix.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>F</strong> (<em>np.ndarray</em>)  The ideal flow matrix.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The stochastic matrix.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>np.ndarray</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">IdealFlow.Network</span> <span class="k">as</span> <span class="nn">net</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="n">net</span><span class="o">.</span><span class="n">IFN</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">F</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.4</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">S</span> <span class="o">=</span> <span class="n">n</span><span class="o">.</span><span class="n">ideal_flow_to_stochastic</span><span class="p">(</span><span class="n">F</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">S</span><span class="p">)</span>
<span class="go">[[0.4 0.6]</span>
<span class="go"> [0.8 0.2]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="IdealFlow.Network.IFN.identify_unique_nodes">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">identify_unique_nodes</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">signature</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">list</span></span></span><a class="headerlink" href="#IdealFlow.Network.IFN.identify_unique_nodes" title="Link to this definition"></a></dt>
<dd><p>Identifies unique nodes in a cycle string.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>signature</strong> (<em>str</em>)  The cycle string with node names.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A sorted list of unique node names.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>list</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">IdealFlow.Network</span> <span class="k">as</span> <span class="nn">net</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="n">net</span><span class="o">.</span><span class="n">IFN</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">identify_unique_nodes</span><span class="p">(</span><span class="s1">&#39;a + b + c + a&#39;</span><span class="p">)</span>
<span class="go">[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="IdealFlow.Network.IFN.in_degree">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">in_degree</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">tuple</span></em><a class="headerlink" href="#IdealFlow.Network.IFN.in_degree" title="Link to this definition"></a></dt>
<dd><p>Return the in-degree (number of incoming edges) for each node and a list of all nodes.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p><dl class="simple">
<dt>A tuple containing two lists:</dt><dd><ul class="simple">
<li><p>List of in-degrees for each node.</p></li>
<li><p>List of nodes corresponding to the in-degrees.</p></li>
</ul>
</dd>
</dl>
</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>tuple</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">IdealFlow.Network</span> <span class="k">as</span> <span class="nn">net</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="n">net</span><span class="o">.</span><span class="n">IFN</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">add_link</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">add_link</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">in_degree</span>
<span class="go">([0, 1, 1], [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="IdealFlow.Network.IFN.in_neighbors">
<span class="sig-name descname"><span class="pre">in_neighbors</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">toNode</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">dict</span></span></span><a class="headerlink" href="#IdealFlow.Network.IFN.in_neighbors" title="Link to this definition"></a></dt>
<dd><p>Return the incoming neighbors and their weights for the given node (predecessors).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>toNode</strong> (<em>str</em>)  The node for which incoming neighbors are required.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A dictionary where keys are incoming nodes and values are edge weights.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>dict</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">IdealFlow.Network</span> <span class="k">as</span> <span class="nn">net</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="n">net</span><span class="o">.</span><span class="n">IFN</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">add_link</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">add_link</span><span class="p">(</span><span class="s1">&#39;c&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">in_neighbors</span><span class="p">(</span><span class="s1">&#39;b&#39;</span><span class="p">)</span>
<span class="go">{&#39;a&#39;: 3, &#39;c&#39;: 2}</span>
</pre></div>
</div>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="IdealFlow.Network.IFN.in_weight">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">in_weight</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">tuple</span></em><a class="headerlink" href="#IdealFlow.Network.IFN.in_weight" title="Link to this definition"></a></dt>
<dd><p>Return the total incoming weight of each node and a list of all nodes.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p><dl class="simple">
<dt>A tuple containing two lists:</dt><dd><ul class="simple">
<li><p>List of total incoming weights for each node.</p></li>
<li><p>List of nodes corresponding to the weights.</p></li>
</ul>
</dd>
</dl>
</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>tuple</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">IdealFlow.Network</span> <span class="k">as</span> <span class="nn">net</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="n">net</span><span class="o">.</span><span class="n">IFN</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">add_link</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">add_link</span><span class="p">(</span><span class="s1">&#39;c&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">in_weight</span>
<span class="go">([0, 5, 0], [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="IdealFlow.Network.IFN.intersect">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">intersect</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">net1</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#IdealFlow.Network.IFN" title="IdealFlow.Network.IFN"><span class="pre">IFN</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">net2</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#IdealFlow.Network.IFN" title="IdealFlow.Network.IFN"><span class="pre">IFN</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#IdealFlow.Network.IFN" title="IdealFlow.Network.IFN"><span class="pre">IFN</span></a></span></span><a class="headerlink" href="#IdealFlow.Network.IFN.intersect" title="Link to this definition"></a></dt>
<dd><p>Return the intersection of two networks.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>net1</strong> (<a class="reference internal" href="#IdealFlow.Network.IFN" title="IdealFlow.Network.IFN"><em>IFN</em></a>)  The first network.</p></li>
<li><p><strong>net2</strong> (<a class="reference internal" href="#IdealFlow.Network.IFN" title="IdealFlow.Network.IFN"><em>IFN</em></a>)  The second network.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A new network representing the intersection of net1 and net2.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="#IdealFlow.Network.IFN" title="IdealFlow.Network.IFN">IFN</a></p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">IdealFlow.Network</span> <span class="k">as</span> <span class="nn">net</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="n">net</span><span class="o">.</span><span class="n">IFN</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">net1</span><span class="p">,</span> <span class="n">net2</span> <span class="o">=</span> <span class="n">net</span><span class="o">.</span><span class="n">IFN</span><span class="p">(),</span> <span class="n">net</span><span class="o">.</span><span class="n">IFN</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">intersect_net</span> <span class="o">=</span> <span class="n">n</span><span class="o">.</span><span class="n">intersect</span><span class="p">(</span><span class="n">net1</span><span class="p">,</span> <span class="n">net2</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="IdealFlow.Network.IFN.inverse_dict">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">inverse_dict</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dic</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">dict</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">dict</span></span></span><a class="headerlink" href="#IdealFlow.Network.IFN.inverse_dict" title="Link to this definition"></a></dt>
<dd><p>Create an inverse dictionary where values become keys and keys become values.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>dic</strong> (<em>dict</em>)  The original dictionary.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Inverse dictionary with values as keys and lists of original keys as values.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>dict</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">IdealFlow.Network</span> <span class="k">as</span> <span class="nn">net</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="n">net</span><span class="o">.</span><span class="n">IFN</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dic</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;a&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">inverse_dict</span><span class="p">(</span><span class="n">dic</span><span class="p">)</span>
<span class="go">{1: [&#39;a&#39;], 2: [&#39;b&#39;, &#39;c&#39;]}</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">dic</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;a&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;e&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span> <span class="s1">&#39;d&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;f&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">inverse_dict</span><span class="p">(</span><span class="n">dic</span><span class="p">)</span>
<span class="go">{1: [&#39;d&#39;], 2: [&#39;c&#39;, &#39;b&#39;, &#39;f&#39;], 3: [&#39;a&#39;, &#39;e&#39;]}</span>
</pre></div>
</div>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="IdealFlow.Network.IFN.is_acyclic">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">is_acyclic</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">bool</span></em><a class="headerlink" href="#IdealFlow.Network.IFN.is_acyclic" title="Link to this definition"></a></dt>
<dd><p>Check if the internal network contains no cycle.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>True if the network is acyclic, False if a cycle is present.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>bool</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">IdealFlow.Network</span> <span class="k">as</span> <span class="nn">net</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="n">net</span><span class="o">.</span><span class="n">IFN</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">is_acyclic</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="IdealFlow.Network.IFN.is_bipartite">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">is_bipartite</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">bool</span></em><a class="headerlink" href="#IdealFlow.Network.IFN.is_bipartite" title="Link to this definition"></a></dt>
<dd><p>Check if the internal network is bipartite.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>True if the network is bipartite, False otherwise.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>bool</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">IdealFlow.Network</span> <span class="k">as</span> <span class="nn">net</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="n">net</span><span class="o">.</span><span class="n">IFN</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">is_bipartite</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="IdealFlow.Network.IFN.is_connected">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">is_connected</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">bool</span></em><a class="headerlink" href="#IdealFlow.Network.IFN.is_connected" title="Link to this definition"></a></dt>
<dd><p>Check if the internal network is connected.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>True if the network is connected, False otherwise.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>bool</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">IdealFlow.Network</span> <span class="k">as</span> <span class="nn">net</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="n">net</span><span class="o">.</span><span class="n">IFN</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">is_connected</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="IdealFlow.Network.IFN.is_contain_cycle">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">is_contain_cycle</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">bool</span></em><a class="headerlink" href="#IdealFlow.Network.IFN.is_contain_cycle" title="Link to this definition"></a></dt>
<dd><p>Check if the internal IFN contains a cycle using in-degree tracking.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>True if a cycle is present, False otherwise.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>bool</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">IdealFlow.Network</span> <span class="k">as</span> <span class="nn">net</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="n">net</span><span class="o">.</span><span class="n">IFN</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">is_contain_cycle</span>
<span class="go">False</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="IdealFlow.Network.IFN.is_cycle_canonical">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">is_cycle_canonical</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">cycle</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="headerlink" href="#IdealFlow.Network.IFN.is_cycle_canonical" title="Link to this definition"></a></dt>
<dd><p>Check if a cycle is canonical by comparing lexicographically sorted and rotated versions.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>cycle</strong> (<em>str</em>)  The cycle string.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>True if the cycle is canonical, otherwise False.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>bool</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">IdealFlow.Network</span> <span class="k">as</span> <span class="nn">net</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="n">net</span><span class="o">.</span><span class="n">IFN</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cycle</span> <span class="o">=</span> <span class="s2">&quot;abc&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">is_cycle_canonical</span><span class="p">(</span><span class="n">cycle</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cycle</span> <span class="o">=</span> <span class="s2">&quot;cab&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">is_cycle_canonical</span><span class="p">(</span><span class="n">cycle</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cycle</span> <span class="o">=</span> <span class="s2">&quot;bca&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">is_cycle_canonical</span><span class="p">(</span><span class="n">cycle</span><span class="p">)</span>
<span class="go">False</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="IdealFlow.Network.IFN.is_cycle_has_coef_1">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">is_cycle_has_coef_1</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">cycle_str</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="headerlink" href="#IdealFlow.Network.IFN.is_cycle_has_coef_1" title="Link to this definition"></a></dt>
<dd><p>Checks if each term in a cycle string has a coefficient of 1.
It does not combine the term.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>cycle_str</strong> (<em>str</em>)  The cycle string, where terms are separated by +.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>True if all terms have a coefficient of 1, otherwise False.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>bool</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">IdealFlow.Network</span> <span class="k">as</span> <span class="nn">net</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="n">net</span><span class="o">.</span><span class="n">IFN</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">is_cycle_has_coef_1</span><span class="p">(</span><span class="s1">&#39;2a+b+c&#39;</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">is_cycle_has_coef_1</span><span class="p">(</span><span class="s1">&#39;a+b+c&#39;</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">is_cycle_has_coef_1</span><span class="p">(</span><span class="s1">&#39;a+b+c+a&#39;</span><span class="p">)</span> <span class="c1"># not combine the terms</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="IdealFlow.Network.IFN.is_edge_in_cycle">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">is_edge_in_cycle</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">i</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">j</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cycle</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="headerlink" href="#IdealFlow.Network.IFN.is_edge_in_cycle" title="Link to this definition"></a></dt>
<dd><p>Check if an edge is in a cycle.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>i</strong> (<em>int</em>)  The row index.</p></li>
<li><p><strong>j</strong> (<em>int</em>)  The column index.</p></li>
<li><p><strong>cycle</strong> (<em>str</em>)  The cycle string.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>True if the edge is in the cycle, otherwise False.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>bool</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">IdealFlow.Network</span> <span class="k">as</span> <span class="nn">net</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="n">net</span><span class="o">.</span><span class="n">IFN</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cycle</span> <span class="o">=</span> <span class="s1">&#39;abc&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">result</span> <span class="o">=</span> <span class="n">n</span><span class="o">.</span><span class="n">is_edge_in_cycle</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">cycle</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="IdealFlow.Network.IFN.is_equal_network">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">is_equal_network</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">net1</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#IdealFlow.Network.IFN" title="IdealFlow.Network.IFN"><span class="pre">IFN</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">net2</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#IdealFlow.Network.IFN" title="IdealFlow.Network.IFN"><span class="pre">IFN</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="headerlink" href="#IdealFlow.Network.IFN.is_equal_network" title="Link to this definition"></a></dt>
<dd><p>Check if two networks are equal by comparing their adjacency lists.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>net1</strong> (<a class="reference internal" href="#IdealFlow.Network.IFN" title="IdealFlow.Network.IFN"><em>IFN</em></a>)  The first network.</p></li>
<li><p><strong>net2</strong> (<a class="reference internal" href="#IdealFlow.Network.IFN" title="IdealFlow.Network.IFN"><em>IFN</em></a>)  The second network.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>True if both networks are equal, False otherwise.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>bool</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">IdealFlow.Network</span> <span class="k">as</span> <span class="nn">net</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="n">net</span><span class="o">.</span><span class="n">IFN</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">net1</span><span class="p">,</span> <span class="n">net2</span> <span class="o">=</span> <span class="n">n</span><span class="p">,</span> <span class="n">n</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">is_equal_network</span><span class="p">(</span><span class="n">net1</span><span class="p">,</span> <span class="n">net2</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="IdealFlow.Network.IFN.is_equal_signature">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">is_equal_signature</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">signature1</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">signature2</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="headerlink" href="#IdealFlow.Network.IFN.is_equal_signature" title="Link to this definition"></a></dt>
<dd><p>Check if two signatures are equal by comparing their canonical cycle dictionaries.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>signature1</strong> (<em>str</em>)  The first network signature.</p></li>
<li><p><strong>signature2</strong> (<em>str</em>)  The second network signature.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>True if the signatures are equal, otherwise False.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>bool</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">IdealFlow.Network</span> <span class="k">as</span> <span class="nn">net</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="n">net</span><span class="o">.</span><span class="n">IFN</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sig1</span> <span class="o">=</span> <span class="s2">&quot;abc + bcd&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sig2</span> <span class="o">=</span> <span class="s2">&quot;bcd + abc&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">result</span> <span class="o">=</span> <span class="n">n</span><span class="o">.</span><span class="n">is_equal_signature</span><span class="p">(</span><span class="n">sig1</span><span class="p">,</span> <span class="n">sig2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>  <span class="c1"># Output: True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="IdealFlow.Network.IFN.is_equivalent_ifn">
<span class="sig-name descname"><span class="pre">is_equivalent_ifn</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ifn</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#IdealFlow.Network.IFN" title="IdealFlow.Network.IFN"><span class="pre">IFN</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="headerlink" href="#IdealFlow.Network.IFN.is_equivalent_ifn" title="Link to this definition"></a></dt>
<dd><p>Check if the current IFN is equivalent to another IFN based on the coefficient of variation of flow.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>ifn</strong> (<a class="reference internal" href="#IdealFlow.Network.IFN" title="IdealFlow.Network.IFN"><em>IFN</em></a>)  The IFN to compare.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>True if both IFNs are equivalent, False otherwise.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>bool</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">IdealFlow.Network</span> <span class="k">as</span> <span class="nn">net</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n1</span> <span class="o">=</span> <span class="n">net</span><span class="o">.</span><span class="n">IFN</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n2</span> <span class="o">=</span> <span class="n">net</span><span class="o">.</span><span class="n">IFN</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n1</span><span class="o">.</span><span class="n">is_equivalent_ifn</span><span class="p">(</span><span class="n">n2</span><span class="p">)</span>
<span class="go">False</span>
</pre></div>
</div>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="IdealFlow.Network.IFN.is_eulerian_cycle">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">is_eulerian_cycle</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">bool</span></em><a class="headerlink" href="#IdealFlow.Network.IFN.is_eulerian_cycle" title="Link to this definition"></a></dt>
<dd><p>Check if the internal network contains an Eulerian cycle.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>True if the network contains an Eulerian cycle, False otherwise.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>bool</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">IdealFlow.Network</span> <span class="k">as</span> <span class="nn">net</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="n">net</span><span class="o">.</span><span class="n">IFN</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">is_eulerian_cycle</span>
<span class="go">False</span>
</pre></div>
</div>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="IdealFlow.Network.IFN.is_ideal_flow">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">is_ideal_flow</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">bool</span></em><a class="headerlink" href="#IdealFlow.Network.IFN.is_ideal_flow" title="Link to this definition"></a></dt>
<dd><p>Check if the network is an ideal flow network (premagic and strongly connected).</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>True if the network is an ideal flow, False otherwise.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>bool</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">IdealFlow.Network</span> <span class="k">as</span> <span class="nn">net</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="n">net</span><span class="o">.</span><span class="n">IFN</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">is_ideal_flow</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="IdealFlow.Network.IFN.is_ideal_flow_matrix">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">is_ideal_flow_matrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mA</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="headerlink" href="#IdealFlow.Network.IFN.is_ideal_flow_matrix" title="Link to this definition"></a></dt>
<dd><p>Check if a matrix is an ideal flow matrix.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>mA</strong> (<em>np.ndarray</em>)  The input matrix.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>True if the matrix is an ideal flow matrix, otherwise False.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>bool</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">IdealFlow.Network</span> <span class="k">as</span> <span class="nn">net</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="n">net</span><span class="o">.</span><span class="n">IFN</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">result</span> <span class="o">=</span> <span class="n">n</span><span class="o">.</span><span class="n">is_ideal_flow_matrix</span><span class="p">(</span><span class="n">M</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="IdealFlow.Network.IFN.is_irreducible_matrix">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">is_irreducible_matrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">M</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="headerlink" href="#IdealFlow.Network.IFN.is_irreducible_matrix" title="Link to this definition"></a></dt>
<dd><p>Check if a matrix is irreducible.
This method is slow for large matrix.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>M</strong> (<em>np.ndarray</em>)  The input matrix.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>True if the matrix is irreducible, otherwise False.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>bool</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">IdealFlow.Network</span> <span class="k">as</span> <span class="nn">net</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="n">net</span><span class="o">.</span><span class="n">IFN</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">result</span> <span class="o">=</span> <span class="n">n</span><span class="o">.</span><span class="n">is_irreducible_matrix</span><span class="p">(</span><span class="n">M</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="IdealFlow.Network.IFN.is_irreducible_signature">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">is_irreducible_signature</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">cycle_signature</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="headerlink" href="#IdealFlow.Network.IFN.is_irreducible_signature" title="Link to this definition"></a></dt>
<dd><p>Check if a cycle signature is irreducible.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>cycle_signature</strong> (<em>str</em>)  The cycle signature.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>True if the signature is irreducible, False otherwise.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>bool</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">IdealFlow.Network</span> <span class="k">as</span> <span class="nn">net</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="n">net</span><span class="o">.</span><span class="n">IFN</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">is_irreducible_signature</span><span class="p">(</span><span class="s2">&quot;abc + abd&quot;</span><span class="p">)</span>
<span class="go">False</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="IdealFlow.Network.IFN.is_non_empty_adj_list">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">is_non_empty_adj_list</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">adjL</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">dict</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="headerlink" href="#IdealFlow.Network.IFN.is_non_empty_adj_list" title="Link to this definition"></a></dt>
<dd><p>Check if the adjacency list is non-empty.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>adjL</strong> (<em>dict</em>)  The adjacency list.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>True if the adjacency list contains at least one link, otherwise False.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>bool</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">IdealFlow.Network</span> <span class="k">as</span> <span class="nn">net</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="n">net</span><span class="o">.</span><span class="n">IFN</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">adjL</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;a&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;b&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">},</span> <span class="s1">&#39;b&#39;</span><span class="p">:</span> <span class="p">{}}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">is_non_empty_adj_list</span><span class="p">(</span><span class="n">adjL</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="IdealFlow.Network.IFN.is_non_negative_matrix">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">is_non_negative_matrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">M</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="headerlink" href="#IdealFlow.Network.IFN.is_non_negative_matrix" title="Link to this definition"></a></dt>
<dd><p>Check if all elements in a matrix are non-negative.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>M</strong> (<em>np.ndarray</em>)  The input matrix.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>True if all elements are non-negative, otherwise False.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>bool</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">IdealFlow.Network</span> <span class="k">as</span> <span class="nn">net</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="n">net</span><span class="o">.</span><span class="n">IFN</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">result</span> <span class="o">=</span> <span class="n">n</span><span class="o">.</span><span class="n">is_non_negative_matrix</span><span class="p">(</span><span class="n">M</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="IdealFlow.Network.IFN.is_path">
<span class="sig-name descname"><span class="pre">is_path</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">trajectory</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="headerlink" href="#IdealFlow.Network.IFN.is_path" title="Link to this definition"></a></dt>
<dd><p>Check if the given trajectory is a valid path.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>trajectory</strong> (<em>list</em>)  A sequence of nodes.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>True if the sequence forms a valid path, False otherwise.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>bool</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">IdealFlow.Network</span> <span class="k">as</span> <span class="nn">net</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="n">net</span><span class="o">.</span><span class="n">IFN</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">add_link</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">add_link</span><span class="p">(</span><span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">is_path</span><span class="p">([</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">])</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="IdealFlow.Network.IFN.is_positive_matrix">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">is_positive_matrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">M</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="headerlink" href="#IdealFlow.Network.IFN.is_positive_matrix" title="Link to this definition"></a></dt>
<dd><p>Check if all elements in a matrix are positive.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>M</strong> (<em>np.ndarray</em>)  The input matrix.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>True if all elements are positive, otherwise False.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>bool</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">IdealFlow.Network</span> <span class="k">as</span> <span class="nn">net</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="n">net</span><span class="o">.</span><span class="n">IFN</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">result</span> <span class="o">=</span> <span class="n">n</span><span class="o">.</span><span class="n">is_positive_matrix</span><span class="p">(</span><span class="n">M</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="IdealFlow.Network.IFN.is_premagic">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">is_premagic</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">bool</span></em><a class="headerlink" href="#IdealFlow.Network.IFN.is_premagic" title="Link to this definition"></a></dt>
<dd><p>Check if the in-weight and out-weight of all nodes are approximately equal.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>True if the in-weight is approximately equal to out-weight for all nodes, False otherwise.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>bool</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">IdealFlow.Network</span> <span class="k">as</span> <span class="nn">net</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="n">net</span><span class="o">.</span><span class="n">IFN</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">is_premagic</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="IdealFlow.Network.IFN.is_premagic_matrix">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">is_premagic_matrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">M</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="headerlink" href="#IdealFlow.Network.IFN.is_premagic_matrix" title="Link to this definition"></a></dt>
<dd><p>Check if a matrix is premagic (row sums equal column sums).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>M</strong> (<em>np.ndarray</em>)  The input matrix.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>True if the matrix is premagic, otherwise False.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>bool</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">IdealFlow.Network</span> <span class="k">as</span> <span class="nn">net</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="n">net</span><span class="o">.</span><span class="n">IFN</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">result</span> <span class="o">=</span> <span class="n">n</span><span class="o">.</span><span class="n">is_premagic_matrix</span><span class="p">(</span><span class="n">M</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="IdealFlow.Network.IFN.is_premier_matrix">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">is_premier_matrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">F</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="headerlink" href="#IdealFlow.Network.IFN.is_premier_matrix" title="Link to this definition"></a></dt>
<dd><p>Check if an ideal flow matrix is premier.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>F</strong> (<em>list</em>)  The ideal flow matrix.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>True if the matrix is premier, otherwise False.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>bool</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">IdealFlow.Network</span> <span class="k">as</span> <span class="nn">net</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">F</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="n">net</span><span class="o">.</span><span class="n">IFN</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">result</span> <span class="o">=</span> <span class="n">n</span><span class="o">.</span><span class="n">is_premier_matrix</span><span class="p">(</span><span class="n">F</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="IdealFlow.Network.IFN.is_premier_signature">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">is_premier_signature</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">net_signature</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="headerlink" href="#IdealFlow.Network.IFN.is_premier_signature" title="Link to this definition"></a></dt>
<dd><p>Check if a network signature is premier (has all cycle and coefficients equal to 1).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>net_signature</strong> (<em>str</em>)  The network signature.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>True if the signature is premier, otherwise False.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>bool</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">IdealFlow.Network</span> <span class="k">as</span> <span class="nn">net</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="n">net</span><span class="o">.</span><span class="n">IFN</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">signature</span> <span class="o">=</span> <span class="s2">&quot;abc + def&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">is_premier_signature</span><span class="p">(</span><span class="n">signature</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">is_premier_signature</span><span class="p">(</span><span class="s2">&quot;abc + 2ab&quot;</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">is_premier_signature</span><span class="p">(</span><span class="s2">&quot;abc + bca + def&quot;</span><span class="p">)</span>
<span class="go">False</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="IdealFlow.Network.IFN.is_reachable">
<span class="sig-name descname"><span class="pre">is_reachable</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">startNode</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">endNode</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="headerlink" href="#IdealFlow.Network.IFN.is_reachable" title="Link to this definition"></a></dt>
<dd><p>Check if a node is reachable from another node using BFS.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>startNode</strong> (<em>str</em>)  The starting node.</p></li>
<li><p><strong>endNode</strong> (<em>str</em>)  The node to check reachability for.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>True if the endNode is reachable from startNode, False otherwise.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>bool</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">IdealFlow.Network</span> <span class="k">as</span> <span class="nn">net</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="n">net</span><span class="o">.</span><span class="n">IFN</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">is_reachable</span><span class="p">(</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;B&#39;</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="IdealFlow.Network.IFN.is_row_stochastic_matrix">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">is_row_stochastic_matrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mA</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="headerlink" href="#IdealFlow.Network.IFN.is_row_stochastic_matrix" title="Link to this definition"></a></dt>
<dd><p>Check if a matrix is row-stochastic (rows sum to 1).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>mA</strong> (<em>np.ndarray</em>)  The input matrix.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>True if the matrix is row-stochastic, otherwise False.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>bool</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">IdealFlow.Network</span> <span class="k">as</span> <span class="nn">net</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="n">net</span><span class="o">.</span><span class="n">IFN</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mA</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.3</span><span class="p">,</span> <span class="mf">0.7</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">is_row_stochastic_matrix</span><span class="p">(</span><span class="n">mA</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="IdealFlow.Network.IFN.is_square_matrix">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">is_square_matrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">M</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="headerlink" href="#IdealFlow.Network.IFN.is_square_matrix" title="Link to this definition"></a></dt>
<dd><p>Check if a matrix is square.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>M</strong> (<em>np.ndarray</em>)  The input matrix.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>True if the matrix is square, False otherwise.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>bool</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">IdealFlow.Network</span> <span class="k">as</span> <span class="nn">net</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="n">net</span><span class="o">.</span><span class="n">IFN</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">result</span> <span class="o">=</span> <span class="n">n</span><span class="o">.</span><span class="n">is_square_matrix</span><span class="p">(</span><span class="n">M</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="IdealFlow.Network.IFN.is_strongly_connected">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">is_strongly_connected</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">bool</span></em><a class="headerlink" href="#IdealFlow.Network.IFN.is_strongly_connected" title="Link to this definition"></a></dt>
<dd><p>Check if the internal network is strongly connected.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>True if the network is strongly connected, False otherwise.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>bool</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">IdealFlow.Network</span> <span class="k">as</span> <span class="nn">net</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="n">net</span><span class="o">.</span><span class="n">IFN</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">is_strongly_connected</span>
<span class="go">False</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="IdealFlow.Network.IFN.is_trajectory_cycle">
<span class="sig-name descname"><span class="pre">is_trajectory_cycle</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">path</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="headerlink" href="#IdealFlow.Network.IFN.is_trajectory_cycle" title="Link to this definition"></a></dt>
<dd><p>Check if the given path forms a cycle (i.e., start and end nodes are the same).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>path</strong> (<em>list</em>)  A sequence of nodes.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>True if the path forms a cycle, False otherwise.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>bool</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">IdealFlow.Network</span> <span class="k">as</span> <span class="nn">net</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="n">net</span><span class="o">.</span><span class="n">IFN</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">add_link</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">is_trajectory_cycle</span><span class="p">([</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">])</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">add_link</span><span class="p">(</span><span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">is_trajectory_cycle</span><span class="p">([</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">])</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="IdealFlow.Network.IFN.is_valid_signature">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">is_valid_signature</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">signature</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="headerlink" href="#IdealFlow.Network.IFN.is_valid_signature" title="Link to this definition"></a></dt>
<dd><p>Check if a network signature is valid by ensuring that all cycles are canonical.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>signature</strong> (<em>str</em>)  The network signature.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>True if the signature is valid, otherwise False.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>bool</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">IdealFlow.Network</span> <span class="k">as</span> <span class="nn">net</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="n">net</span><span class="o">.</span><span class="n">IFN</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">is_valid_signature</span><span class="p">(</span><span class="s2">&quot;abc + bcd&quot;</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">is_valid_signature</span><span class="p">(</span><span class="s2">&quot;5abc+2bcd&quot;</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">is_valid_signature</span><span class="p">(</span><span class="s2">&quot;bac + dcb&quot;</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">is_valid_signature</span><span class="p">(</span><span class="s2">&quot;cbcd&quot;</span><span class="p">)</span>
<span class="go">False</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="IdealFlow.Network.IFN.kappa">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">kappa</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">F</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">float</span></span></span><a class="headerlink" href="#IdealFlow.Network.IFN.kappa" title="Link to this definition"></a></dt>
<dd><p>Compute the kappa value of a flow matrix.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>F</strong> (<em>list</em>)  The flow matrix.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The kappa value.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">IdealFlow.Network</span> <span class="k">as</span> <span class="nn">net</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">F</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="n">net</span><span class="o">.</span><span class="n">IFN</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">kappa_value</span> <span class="o">=</span> <span class="n">n</span><span class="o">.</span><span class="n">kappa</span><span class="p">(</span><span class="n">F</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">kappa_value</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="IdealFlow.Network.IFN.link_combination">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">link_combination</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">trajectory</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">list</span></span></span><a class="headerlink" href="#IdealFlow.Network.IFN.link_combination" title="Link to this definition"></a></dt>
<dd><p>Given a list of nodes, generate all one-way link combinations.
Note: the trajectory is not necessarily a path in the network</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>trajectory</strong> (<em>list</em>)  A list of nodes.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A list of one-way link combinations.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>list</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">IdealFlow.Network</span> <span class="k">as</span> <span class="nn">net</span>     <span class="c1"># import package.module as alias</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="n">net</span><span class="o">.</span><span class="n">IFN</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">link_combination</span><span class="p">([</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">])</span>
<span class="go">[[&#39;a&#39;, &#39;b&#39;], [&#39;a&#39;, &#39;c&#39;], [&#39;b&#39;, &#39;c&#39;]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">link_combination</span><span class="p">([</span><span class="s1">&#39;a&#39;</span><span class="p">,</span><span class="s1">&#39;b&#39;</span><span class="p">,</span><span class="s1">&#39;c&#39;</span><span class="p">,</span><span class="s1">&#39;d&#39;</span><span class="p">])</span>
<span class="go">[[&#39;a&#39;,&#39;b&#39;],[&#39;a&#39;,&#39;c&#39;],[&#39;a&#39;,&#39;d&#39;],[&#39;b&#39;,&#39;c&#39;],[&#39;b&#39;,&#39;d&#39;],[&#39;c&#39;,&#39;d&#39;]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="IdealFlow.Network.IFN.link_cycle_matrix">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">link_cycle_matrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">F</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">dict</span></span></span><a class="headerlink" href="#IdealFlow.Network.IFN.link_cycle_matrix" title="Link to this definition"></a></dt>
<dd><p>Generate the link-cycle matrix from a flow matrix.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>F</strong> (<em>list</em><em> of </em><em>list</em><em> of </em><em>int/float</em>)  The flow matrix.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A dictionary containing the link-cycle matrix, cycles, and links.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>dict</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">IdealFlow.Network</span> <span class="k">as</span> <span class="nn">net</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="n">net</span><span class="o">.</span><span class="n">IFN</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">F</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">result</span> <span class="o">=</span> <span class="n">n</span><span class="o">.</span><span class="n">link_cycle_matrix</span><span class="p">(</span><span class="n">F</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="IdealFlow.Network.IFN.link_permutation">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">link_permutation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">trajectory</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">list</span></span></span><a class="headerlink" href="#IdealFlow.Network.IFN.link_permutation" title="Link to this definition"></a></dt>
<dd><p>Given a list of nodes, generate all two-way link permutations.
Note: the trajectory is not necessarily a path in the network</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>trajectory</strong> (<em>list</em>)  A list of nodes.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A list of two-way link permutations.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>list</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">IdealFlow.Network</span> <span class="k">as</span> <span class="nn">net</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="n">net</span><span class="o">.</span><span class="n">IFN</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">link_permutation</span><span class="p">([</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">])</span>
<span class="go">[[&#39;a&#39;, &#39;b&#39;], [&#39;a&#39;, &#39;c&#39;], [&#39;b&#39;, &#39;a&#39;], [&#39;b&#39;, &#39;c&#39;], [&#39;c&#39;, &#39;a&#39;], [&#39;c&#39;, &#39;b&#39;]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">link_permutation</span><span class="p">([</span><span class="s1">&#39;a&#39;</span><span class="p">,</span><span class="s1">&#39;b&#39;</span><span class="p">,</span><span class="s1">&#39;c&#39;</span><span class="p">,</span><span class="s1">&#39;d&#39;</span><span class="p">])</span>
<span class="go">[[&#39;a&#39;,&#39;b&#39;],[&#39;a&#39;,&#39;c&#39;],[&#39;a&#39;,&#39;d&#39;],[&#39;b&#39;,&#39;c&#39;],[&#39;b&#39;,&#39;d&#39;],[&#39;c&#39;,&#39;d&#39;],</span>
<span class="go">[&#39;b&#39;,&#39;a&#39;],[&#39;c&#39;,&#39;a&#39;],[&#39;d&#39;,&#39;a&#39;],[&#39;c&#39;,&#39;b&#39;],[&#39;d&#39;,&#39;b&#39;],[&#39;d&#39;,&#39;c&#39;]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="IdealFlow.Network.IFN.load">
<span class="sig-name descname"><span class="pre">load</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fileName</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#IdealFlow.Network.IFN.load" title="Link to this definition"></a></dt>
<dd><p>Load the adjacency list from a JSON file.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>fileName</strong> (<em>str</em>)  The name of the file to load the data from.</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">IdealFlow.Network</span> <span class="k">as</span> <span class="nn">net</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="n">net</span><span class="o">.</span><span class="n">IFN</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s1">&#39;network.json&#39;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="IdealFlow.Network.IFN.load_adj_list">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">load_adj_list</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">filename</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">dict</span></span></span><a class="headerlink" href="#IdealFlow.Network.IFN.load_adj_list" title="Link to this definition"></a></dt>
<dd><p>Load an adjacency list from a JSON file.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>filename</strong> (<em>str</em>)  The name of the file to load from.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The loaded adjacency list.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>dict</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">IdealFlow.Network</span> <span class="k">as</span> <span class="nn">net</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="n">net</span><span class="o">.</span><span class="n">IFN</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">adjL</span> <span class="o">=</span> <span class="n">n</span><span class="o">.</span><span class="n">load_adj_list</span><span class="p">(</span><span class="s1">&#39;adj_list.json&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">adjL</span><span class="p">)</span>
<span class="go">{&#39;a&#39;: {&#39;b&#39;: 1}, &#39;b&#39;: {}}</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="IdealFlow.Network.IFN.markov">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">markov</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">S</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kappa</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">ndarray</span></span></span><a class="headerlink" href="#IdealFlow.Network.IFN.markov" title="Link to this definition"></a></dt>
<dd><p>Compute the steady-state Markov vector from a stochastic matrix.
Exact computation approach.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>S</strong> (<em>np.ndarray</em>)  The stochastic matrix.</p></li>
<li><p><strong>kappa</strong> (<em>float</em>)  Total of the Markov vector. Default is 1.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The Markov chain.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>np.ndarray</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">IdealFlow.Network</span> <span class="k">as</span> <span class="nn">net</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="n">net</span><span class="o">.</span><span class="n">IFN</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">S</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pi</span> <span class="o">=</span> <span class="n">n</span><span class="o">.</span><span class="n">markov</span><span class="p">(</span><span class="n">S</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">pi</span><span class="p">)</span>
<span class="go">[[0.5]</span>
<span class="go"> [0.5]]</span>
</pre></div>
</div>
<p>Previous version: steadyStateMC()</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#IdealFlow.Network.IFN.stochastic_to_pi" title="IdealFlow.Network.IFN.stochastic_to_pi"><code class="xref py py-meth docutils literal notranslate"><span class="pre">stochastic_to_pi()</span></code></a></p>
<p><a class="reference internal" href="#IdealFlow.Network.IFN.ideal_flow" title="IdealFlow.Network.IFN.ideal_flow"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ideal_flow()</span></code></a></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="IdealFlow.Network.IFN.match">
<span class="sig-name descname"><span class="pre">match</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">trajectory</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dicIFNs</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">dict</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">tuple</span></span></span><a class="headerlink" href="#IdealFlow.Network.IFN.match" title="Link to this definition"></a></dt>
<dd><p>Return the IFN from the dictionary with the maximum trajectory entropy and percentage of max entropy/sum of entropy.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>trajectory</strong> (<em>list</em>)  A list of nodes representing the trajectory.</p></li>
<li><p><strong>dicIFNs</strong> (<em>dict</em>)  A dictionary where the keys are IFN names and values are IFN objects.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The name of the IFN with the maximum entropy and the percentage (float).</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>tuple</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">n1</span><span class="p">,</span> <span class="n">n2</span> <span class="o">=</span> <span class="n">IFN</span><span class="p">(),</span> <span class="n">IFN</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">match</span><span class="p">([</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">],</span> <span class="p">{</span><span class="s1">&#39;IFN1&#39;</span><span class="p">:</span> <span class="n">n1</span><span class="p">,</span> <span class="s1">&#39;IFN2&#39;</span><span class="p">:</span> <span class="n">n2</span><span class="p">})</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="IdealFlow.Network.IFN.matrix_apply_cycle">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">matrix_apply_cycle</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">flow_matrix</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cycle</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">flow</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">list</span></span></span><a class="headerlink" href="#IdealFlow.Network.IFN.matrix_apply_cycle" title="Link to this definition"></a></dt>
<dd><p>Return the updated flow matrix after applying flow unit along the given cycle.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>flow_matrix</strong> (<em>list</em>)  The flow matrix.</p></li>
<li><p><strong>cycle</strong> (<em>str</em>)  The cycle string.</p></li>
<li><p><strong>flow</strong> (<em>float</em>)  The flow to apply. Default is 1.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The updated flow matrix.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>list</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">IdealFlow.Network</span> <span class="k">as</span> <span class="nn">net</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">flow_matrix</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cycle</span> <span class="o">=</span> <span class="s1">&#39;ab&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="n">net</span><span class="o">.</span><span class="n">IFN</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">updated_matrix</span> <span class="o">=</span> <span class="n">n</span><span class="o">.</span><span class="n">matrix_apply_cycle</span><span class="p">(</span><span class="n">flow_matrix</span><span class="p">,</span> <span class="n">cycle</span><span class="p">,</span> <span class="n">flow</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">updated_matrix</span><span class="p">)</span>
<span class="go">[[0, 4], [5, 0]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="IdealFlow.Network.IFN.matrix_replace_value">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">matrix_replace_value</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">matrix</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">old_value</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">new_value</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">list</span></span></span><a class="headerlink" href="#IdealFlow.Network.IFN.matrix_replace_value" title="Link to this definition"></a></dt>
<dd><p>Replace all occurrences of <cite>old_value</cite> with <cite>new_value</cite> in a matrix.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>matrix</strong> (<em>list</em>)  The matrix to modify.</p></li>
<li><p><strong>old_value</strong> (<em>float</em>)  The value to replace.</p></li>
<li><p><strong>new_value</strong> (<em>float</em>)  The value to use as a replacement.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The modified matrix.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>list</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">IdealFlow.Network</span> <span class="k">as</span> <span class="nn">net</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="n">net</span><span class="o">.</span><span class="n">IFN</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">matrix</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">matrix_replace_value</span><span class="p">(</span><span class="n">matrix</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="go">[[1, 0], [0, 3]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="IdealFlow.Network.IFN.matrix_to_adj_list">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">matrix_to_adj_list</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">matrix</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">dict</span></span></span><a class="headerlink" href="#IdealFlow.Network.IFN.matrix_to_adj_list" title="Link to this definition"></a></dt>
<dd><p>Convert a weighted square matrix to an adjacency list.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>matrix</strong> (<em>np.ndarray</em>)  The weighted square matrix.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The adjacency list.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>dict</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">IdealFlow.Network</span> <span class="k">as</span> <span class="nn">net</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="n">net</span><span class="o">.</span><span class="n">IFN</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">adjL</span> <span class="o">=</span> <span class="n">n</span><span class="o">.</span><span class="n">matrix_to_adj_list</span><span class="p">(</span><span class="n">matrix</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">adjL</span><span class="p">)</span>
<span class="go">{&#39;0&#39;: {&#39;1&#39;: 1, &#39;2&#39;: 2}, &#39;1&#39;: {&#39;2&#39;: 3}, &#39;2&#39;: {}}</span>
</pre></div>
</div>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="IdealFlow.Network.IFN.max_flow">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">max_flow</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">float</span></em><a class="headerlink" href="#IdealFlow.Network.IFN.max_flow" title="Link to this definition"></a></dt>
<dd><p>Find the internal maximum flow value in the network.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The maximum flow in the network.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>float</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">IdealFlow.Network</span> <span class="k">as</span> <span class="nn">net</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">C</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="n">net</span><span class="o">.</span><span class="n">IFN</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">set_matrix</span><span class="p">(</span><span class="n">C</span><span class="p">,[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span><span class="s1">&#39;b&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">max_flow</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="IdealFlow.Network.IFN.max_flow_matrix">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">max_flow_matrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">F</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">float</span></span></span><a class="headerlink" href="#IdealFlow.Network.IFN.max_flow_matrix" title="Link to this definition"></a></dt>
<dd><p>Compute the maximum flow value of a flow matrix.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>F</strong> (<em>list</em>)  The flow matrix.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The maximum flow value.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">IdealFlow.Network</span> <span class="k">as</span> <span class="nn">net</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">F</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="n">net</span><span class="o">.</span><span class="n">IFN</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">max_flow_value</span> <span class="o">=</span> <span class="n">n</span><span class="o">.</span><span class="n">max_flow_matrix</span><span class="p">(</span><span class="n">F</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">max_flow_value</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="IdealFlow.Network.IFN.max_flow_path">
<span class="sig-name descname"><span class="pre">max_flow_path</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">startNode</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">endNode</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#IdealFlow.Network.IFN.max_flow_path" title="Link to this definition"></a></dt>
<dd><p>Find the path from startNode to endNode with the maximum total flow (sum of link weights).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>startNode</strong> (<em>str</em>)  The starting node.</p></li>
<li><p><strong>endNode</strong> (<em>str</em>)  The ending node.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A tuple containing the maximum flow and the path as a list of nodes.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>tuple</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">IdealFlow.Network</span> <span class="k">as</span> <span class="nn">net</span>     <span class="c1"># import package.module as alias</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="n">net</span><span class="o">.</span><span class="n">IFN</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">adjList</span> <span class="o">=</span> <span class="p">{</span>
<span class="go">        &#39;a&#39;: {&#39;c&#39;: 1, &#39;d&#39;: 2},</span>
<span class="go">        &#39;b&#39;: {&#39;c&#39;: 1, &#39;e&#39;: 3},</span>
<span class="go">        &#39;c&#39;: {&#39;e&#39;: 5},</span>
<span class="go">        &#39;d&#39;: {&#39;c&#39;: 5},</span>
<span class="go">        &#39;e&#39;: {&#39;a&#39;: 3},</span>
<span class="go">        &#39;#Z#&#39;: {&#39;a&#39;: 0, &#39;b&#39;: 0}  # Cloud node connections</span>
<span class="go">    }</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">set_data</span><span class="p">(</span><span class="n">adjList</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">max_flow</span><span class="p">,</span> <span class="n">max_path</span> <span class="o">=</span> <span class="n">network</span><span class="o">.</span><span class="n">max_flow_path</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;e&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Maximum flow from &#39;a&#39; to &#39;e&#39;: </span><span class="si">{</span><span class="n">max_flow</span><span class="si">}</span><span class="s2">, Path: </span><span class="si">{</span><span class="n">max_path</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="IdealFlow.Network.IFN.max_network_entropy">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">max_network_entropy</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">P</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">tuple</span></span></span><a class="headerlink" href="#IdealFlow.Network.IFN.max_network_entropy" title="Link to this definition"></a></dt>
<dd><p>Compute maximum network entropy for a given probability matrix.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>P</strong> (<em>list</em>)  The probability matrix.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The entropy, entropy ratio, and maximum entropy.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>tuple</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">IdealFlow.Network</span> <span class="k">as</span> <span class="nn">net</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">P</span> <span class="o">=</span> <span class="p">[[</span><span class="mf">0.25</span><span class="p">,</span> <span class="mf">0.75</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.6</span><span class="p">,</span> <span class="mf">0.4</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="n">net</span><span class="o">.</span><span class="n">IFN</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">max_entropy</span> <span class="o">=</span> <span class="n">n</span><span class="o">.</span><span class="n">max_network_entropy</span><span class="p">(</span><span class="n">P</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">max_entropy</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="IdealFlow.Network.IFN.merge_adjacency_list">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">merge_adjacency_list</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">adj_list1</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">dict</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">adj_list2</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">dict</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">dict</span></span></span><a class="headerlink" href="#IdealFlow.Network.IFN.merge_adjacency_list" title="Link to this definition"></a></dt>
<dd><p>Merge two adjacency lists by combining their weights.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>adj_list1</strong> (<em>dict</em>)  The first adjacency list.</p></li>
<li><p><strong>adj_list2</strong> (<em>dict</em>)  The second adjacency list.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The merged adjacency list.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>dict</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">IdealFlow.Network</span> <span class="k">as</span> <span class="nn">net</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="n">net</span><span class="o">.</span><span class="n">IFN</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">adj_list1</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;a&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;b&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">}}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">adj_list2</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;b&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;c&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">}}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">merge_adjacency_list</span><span class="p">(</span><span class="n">adj_list1</span><span class="p">,</span> <span class="n">adj_list2</span><span class="p">)</span>
<span class="go">{&#39;a&#39;: {&#39;b&#39;: 1}, &#39;b&#39;: {&#39;c&#39;: 2}}</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="IdealFlow.Network.IFN.merge_signatures">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">merge_signatures</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sig1</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sig2</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">str</span></span></span><a class="headerlink" href="#IdealFlow.Network.IFN.merge_signatures" title="Link to this definition"></a></dt>
<dd><p>Merge two network signatures into one.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>sig1</strong> (<em>str</em>)  The first network signature.</p></li>
<li><p><strong>sig2</strong> (<em>str</em>)  The second network signature.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The merged network signature.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>str</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">IdealFlow.Network</span> <span class="k">as</span> <span class="nn">net</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="n">net</span><span class="o">.</span><span class="n">IFN</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">merge_signatures</span><span class="p">(</span><span class="s1">&#39;abc&#39;</span><span class="p">,</span> <span class="s1">&#39;def&#39;</span><span class="p">)</span>
<span class="go">&#39;abc + def&#39;</span>
</pre></div>
</div>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="IdealFlow.Network.IFN.min_flow">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">min_flow</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">float</span></em><a class="headerlink" href="#IdealFlow.Network.IFN.min_flow" title="Link to this definition"></a></dt>
<dd><p>Return the internal min flow in the network</p>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">IdealFlow.Network</span> <span class="k">as</span> <span class="nn">net</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">C</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="n">net</span><span class="o">.</span><span class="n">IFN</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">set_matrix</span><span class="p">(</span><span class="n">C</span><span class="p">,[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span><span class="s1">&#39;b&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">min_flow</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="IdealFlow.Network.IFN.min_flow_matrix">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">min_flow_matrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">F</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">float</span></span></span><a class="headerlink" href="#IdealFlow.Network.IFN.min_flow_matrix" title="Link to this definition"></a></dt>
<dd><p>Compute the minimum flow value of a flow matrix.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>F</strong> (<em>list</em>)  The flow matrix.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The minimum flow value.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">IdealFlow.Network</span> <span class="k">as</span> <span class="nn">net</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">F</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="n">net</span><span class="o">.</span><span class="n">IFN</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">min_flow_value</span> <span class="o">=</span> <span class="n">n</span><span class="o">.</span><span class="n">min_flow_matrix</span><span class="p">(</span><span class="n">F</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">min_flow_value</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="IdealFlow.Network.IFN.min_flow_path">
<span class="sig-name descname"><span class="pre">min_flow_path</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">startNode</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">endNode</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#IdealFlow.Network.IFN.min_flow_path" title="Link to this definition"></a></dt>
<dd><p>Find the path from startNode to endNode with the minimum total flow (sum of link weights).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>startNode</strong> (<em>str</em>)  The starting node.</p></li>
<li><p><strong>endNode</strong> (<em>str</em>)  The ending node.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A tuple containing the minimum flow and the path as a list of nodes.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>tuple</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">IdealFlow.Network</span> <span class="k">as</span> <span class="nn">net</span>     <span class="c1"># import package.module as alias</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="n">net</span><span class="o">.</span><span class="n">IFN</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">adjList</span> <span class="o">=</span> <span class="p">{</span>
<span class="go">        &#39;a&#39;: {&#39;c&#39;: 1, &#39;d&#39;: 2},</span>
<span class="go">        &#39;b&#39;: {&#39;c&#39;: 1, &#39;e&#39;: 3},</span>
<span class="go">        &#39;c&#39;: {&#39;e&#39;: 5},</span>
<span class="go">        &#39;d&#39;: {&#39;c&#39;: 5},</span>
<span class="go">        &#39;e&#39;: {&#39;a&#39;: 3},</span>
<span class="go">        &#39;#Z#&#39;: {&#39;a&#39;: 0, &#39;b&#39;: 0}  # Cloud node connections</span>
<span class="go">    }</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">set_data</span><span class="p">(</span><span class="n">adjList</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">min_flow</span><span class="p">,</span> <span class="n">min_path</span> <span class="o">=</span> <span class="n">n</span><span class="o">.</span><span class="n">min_flow_path</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;e&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Minimum flow from &#39;a&#39; to &#39;e&#39;: </span><span class="si">{</span><span class="n">min_flow</span><span class="si">}</span><span class="s2">, Path: </span><span class="si">{</span><span class="n">min_path</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="IdealFlow.Network.IFN.min_irreducible">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">min_irreducible</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">k</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">ndarray</span></span></span><a class="headerlink" href="#IdealFlow.Network.IFN.min_irreducible" title="Link to this definition"></a></dt>
<dd><p>Generate the minimum irreducible matrix of size k.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>k</strong> (<em>int</em>)  The size of the matrix.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The minimum irreducible matrix.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>np.ndarray</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">IdealFlow.Network</span> <span class="k">as</span> <span class="nn">net</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="n">net</span><span class="o">.</span><span class="n">IFN</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">n</span><span class="o">.</span><span class="n">min_irreducible</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="go">[[0 1 0]</span>
<span class="go"> [0 0 1]</span>
<span class="go"> [1 0 0]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="IdealFlow.Network.IFN.network_delete_cloud">
<span class="sig-name descname"><span class="pre">network_delete_cloud</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#IdealFlow.Network.IFN" title="IdealFlow.Network.IFN"><span class="pre">IFN</span></a></span></span><a class="headerlink" href="#IdealFlow.Network.IFN.network_delete_cloud" title="Link to this definition"></a></dt>
<dd><p>Return a duplicate of the current network, with the cloud node removed.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>A new network without the cloud node.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference internal" href="#IdealFlow.Network.IFN" title="IdealFlow.Network.IFN">IFN</a></p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">IdealFlow.Network</span> <span class="k">as</span> <span class="nn">net</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="n">net</span><span class="o">.</span><span class="n">IFN</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">clean_net</span> <span class="o">=</span> <span class="n">n</span><span class="o">.</span><span class="n">network_delete_cloud</span><span class="p">()</span>
</pre></div>
</div>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="IdealFlow.Network.IFN.network_entropy">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">network_entropy</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">float</span></em><a class="headerlink" href="#IdealFlow.Network.IFN.network_entropy" title="Link to this definition"></a></dt>
<dd><p>Calculate the network entropy based on the stochastic flow matrix.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The network entropy.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>float</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">IdealFlow.Network</span> <span class="k">as</span> <span class="nn">net</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">F</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="n">net</span><span class="o">.</span><span class="n">IFN</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">set_matrix</span><span class="p">(</span><span class="n">F</span><span class="p">,[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span><span class="s1">&#39;b&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">network_entropy</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="IdealFlow.Network.IFN.network_entropy_matrix">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">network_entropy_matrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">F</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">float</span></span></span><a class="headerlink" href="#IdealFlow.Network.IFN.network_entropy_matrix" title="Link to this definition"></a></dt>
<dd><p>Compute network entropy for a given flow matrix.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>F</strong> (<em>list</em>)  The flow matrix.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The network entropy.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">IdealFlow.Network</span> <span class="k">as</span> <span class="nn">net</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">F</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="n">net</span><span class="o">.</span><span class="n">IFN</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">entropy</span> <span class="o">=</span> <span class="n">n</span><span class="o">.</span><span class="n">network_entropy_matrix</span><span class="p">(</span><span class="n">F</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">entropy</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="IdealFlow.Network.IFN.network_entropy_ratio">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">network_entropy_ratio</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">float</span></em><a class="headerlink" href="#IdealFlow.Network.IFN.network_entropy_ratio" title="Link to this definition"></a></dt>
<dd><p>Return the internal network entropy ratio of flows in the network</p>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">IdealFlow.Network</span> <span class="k">as</span> <span class="nn">net</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">C</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="n">net</span><span class="o">.</span><span class="n">IFN</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">set_matrix</span><span class="p">(</span><span class="n">C</span><span class="p">,[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span><span class="s1">&#39;b&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">network_entropy_ratio</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="IdealFlow.Network.IFN.network_entropy_ratio_matrix">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">network_entropy_ratio_matrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">F</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">float</span></span></span><a class="headerlink" href="#IdealFlow.Network.IFN.network_entropy_ratio_matrix" title="Link to this definition"></a></dt>
<dd><p>Compute network entropy ratio for a given flow matrix.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>F</strong> (<em>list</em>)  The flow matrix.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The network entropy ratio.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">IdealFlow.Network</span> <span class="k">as</span> <span class="nn">net</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">F</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="n">net</span><span class="o">.</span><span class="n">IFN</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ratio</span> <span class="o">=</span> <span class="n">n</span><span class="o">.</span><span class="n">network_entropy_ratio_matrix</span><span class="p">(</span><span class="n">F</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">ratio</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="IdealFlow.Network.IFN.network_probability">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">network_probability</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">dict</span></em><a class="headerlink" href="#IdealFlow.Network.IFN.network_probability" title="Link to this definition"></a></dt>
<dd><p>Return the adjacency list with link probabilities calculated from the total flow (kappa).</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The adjacency list with link probabilities.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>dict</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">IdealFlow.Network</span> <span class="k">as</span> <span class="nn">net</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="n">net</span><span class="o">.</span><span class="n">IFN</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">add_link</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">add_link</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">network_probability</span>
<span class="go">{&#39;a&#39;: {&#39;b&#39;: 0.6, &#39;c&#39;: 0.4}, &#39;b&#39;: {}, &#39;c&#39;: {}}</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="IdealFlow.Network.IFN.node_index">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">node_index</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">int</span></span></span><a class="headerlink" href="#IdealFlow.Network.IFN.node_index" title="Link to this definition"></a></dt>
<dd><p>Convert a name to a unique index.
- Single lowercase letter: returns an index between 0-25.
- Single uppercase letter: returns an index between 26-51.
- Single digit or Base62 character: returns its corresponding index starting from 52.
- Multi-character name: returns a Base62-encoded index after 62.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>name</strong> (<em>str</em>)  The name to convert to an index.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The corresponding node index.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>int</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">IdealFlow.Network</span> <span class="k">as</span> <span class="nn">net</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="n">net</span><span class="o">.</span><span class="n">IFN</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">node_index</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">)</span>
<span class="go">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">node_index</span><span class="p">(</span><span class="s1">&#39;A&#39;</span><span class="p">)</span>
<span class="go">26</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">node_index</span><span class="p">(</span><span class="s1">&#39;0&#39;</span><span class="p">)</span>
<span class="go">52</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">node_index</span><span class="p">(</span><span class="s1">&#39;aa&#39;</span><span class="p">)</span>
<span class="go">682</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="IdealFlow.Network.IFN.node_name">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">node_name</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">index</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">str</span></span></span><a class="headerlink" href="#IdealFlow.Network.IFN.node_name" title="Link to this definition"></a></dt>
<dd><p>Convert an index back into a node name based on the original node_index logic.
Generate a node name based on an index, using letters and base62 encoding.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>index</strong> (<em>int</em>)  The index to convert to a node name.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The node name.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>str</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">IdealFlow.Network</span> <span class="k">as</span> <span class="nn">net</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="n">net</span><span class="o">.</span><span class="n">IFN</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">node_name</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="go">&#39;a&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">node_name</span><span class="p">(</span><span class="mi">26</span><span class="p">)</span>
<span class="go">&#39;A&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">node_name</span><span class="p">(</span><span class="mi">52</span><span class="p">)</span>
<span class="go">&#39;0&#39;  # Example base62 string for index 52</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">node_name</span><span class="p">(</span><span class="mi">682</span><span class="p">)</span>
<span class="go">&#39;aa&#39;</span>
</pre></div>
</div>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="IdealFlow.Network.IFN.nodes">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">nodes</span></span><a class="headerlink" href="#IdealFlow.Network.IFN.nodes" title="Link to this definition"></a></dt>
<dd><p>Property to returns a list of all nodes in the network.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>A list of nodes in the network.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>list</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">IdealFlow.Network</span> <span class="k">as</span> <span class="nn">net</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="n">net</span><span class="o">.</span><span class="n">IFN</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">add_link</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span><span class="s1">&#39;b&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">nodes</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="IdealFlow.Network.IFN.nodes_flow">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">nodes_flow</span></span><a class="headerlink" href="#IdealFlow.Network.IFN.nodes_flow" title="Link to this definition"></a></dt>
<dd><p>Property to returns the flow associated with each node in the network.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p><p>A dictionary where keys are node identifiers and values are their respective flows.</p>
<p>Example:
&gt;&gt;&gt; import IdealFlow.Network as net
&gt;&gt;&gt; n = net.IFN()
&gt;&gt;&gt; n.add_link(a,b,5)
&gt;&gt;&gt; print(n.nodes_flow)</p>
</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>dict</p>
</dd>
</dl>
<p>This property is useful for node flow analysis because node flow of an IFN must be the same as pi from markov.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="IdealFlow.Network.IFN.num_to_excel_col">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">num_to_excel_col</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">num</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">str</span></span></span><a class="headerlink" href="#IdealFlow.Network.IFN.num_to_excel_col" title="Link to this definition"></a></dt>
<dd><p>Convert a number to an Excel-style column label.
such as <cite>a, b, , z, aa, ab, , az, ba, </cite>
Use it to rename the variable.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>num</strong> (<em>int</em>)  The number to convert.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The Excel column label.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>str</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>ValueError</strong>  If the number is less than 1.</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">IdealFlow.Network</span> <span class="k">as</span> <span class="nn">net</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="n">net</span><span class="o">.</span><span class="n">IFN</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">num_to_excel_col</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">&#39;a&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">num_to_excel_col</span><span class="p">(</span><span class="mi">27</span><span class="p">)</span>
<span class="go">&#39;aa&#39;</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="IdealFlow.Network.IFN.num_to_str_fraction">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">num_to_str_fraction</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">num</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">str</span></span></span><a class="headerlink" href="#IdealFlow.Network.IFN.num_to_str_fraction" title="Link to this definition"></a></dt>
<dd><p>Converts a number to a string fraction representation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>num</strong> (<em>float</em>)  The number to convert.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The string representation of the fraction.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>str</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">IdealFlow.Network</span> <span class="k">as</span> <span class="nn">net</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="n">net</span><span class="o">.</span><span class="n">IFN</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">num_to_str_fraction</span><span class="p">(</span><span class="mf">0.75</span><span class="p">)</span>
<span class="go">&#39;3/4&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">num_to_str_fraction</span><span class="p">(</span><span class="mf">0.111111</span><span class="p">)</span>
<span class="go">&#39;1/9&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">num_to_str_fraction</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span>
<span class="go">&#39;355/113&#39;</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="IdealFlow.Network.IFN.order_markov_higher">
<span class="sig-name descname"><span class="pre">order_markov_higher</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">trajectory</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">order</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">list</span></span></span><a class="headerlink" href="#IdealFlow.Network.IFN.order_markov_higher" title="Link to this definition"></a></dt>
<dd><p>Convert a first-order Markov trajectory into a higher-order Markov trajectory.</p>
<dl class="simple">
<dt>Agreement:</dt><dd><p>separator between node in supernode is |
cloud node is #z# and always first order</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>trajectory</strong> (<em>list</em>)  A list of nodes representing the first-order Markov trajectory in hash code.</p></li>
<li><p><strong>order</strong> (<em>int</em>)  The desired (higher) Markov order.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A list of supernodes of K order representing the higher-order Markov trajectory.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>list</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">IdealFlow.Network</span> <span class="k">as</span> <span class="nn">net</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="n">net</span><span class="o">.</span><span class="n">IFN</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">order_markov_higher</span><span class="p">([</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">],</span> <span class="mi">2</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="IdealFlow.Network.IFN.order_markov_lower">
<span class="sig-name descname"><span class="pre">order_markov_lower</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">trajSuper</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">list</span></span></span><a class="headerlink" href="#IdealFlow.Network.IFN.order_markov_lower" title="Link to this definition"></a></dt>
<dd><p>Convert a high-order Markov trajectory into a first-order Markov trajectory.</p>
<p>Agreement: Separator between nodes in a supernode is |. Cloud node is #z# and always first-order.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>trajSuper</strong> (<em>list</em>)  A list of supernodes of K order representing the trajectory.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A list representing the first-order Markov trajectory in hash code.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>list</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">IdealFlow.Network</span> <span class="k">as</span> <span class="nn">net</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="n">net</span><span class="o">.</span><span class="n">IFN</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">order_markov_lower</span><span class="p">([</span><span class="s1">&#39;a|b&#39;</span><span class="p">,</span> <span class="s1">&#39;b|c&#39;</span><span class="p">,</span> <span class="s1">&#39;#z#&#39;</span><span class="p">])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="IdealFlow.Network.IFN.out_degree">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">out_degree</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">tuple</span></em><a class="headerlink" href="#IdealFlow.Network.IFN.out_degree" title="Link to this definition"></a></dt>
<dd><p>Return the out-degree (number of outgoing edges) for each node and a list of all nodes.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p><dl class="simple">
<dt>A tuple containing two lists:</dt><dd><ul class="simple">
<li><p>List of out-degrees for each node.</p></li>
<li><p>List of nodes corresponding to the out-degrees.</p></li>
</ul>
</dd>
</dl>
</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>tuple</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">IdealFlow.Network</span> <span class="k">as</span> <span class="nn">net</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="n">net</span><span class="o">.</span><span class="n">IFN</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">add_link</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">add_link</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">out_degree</span>
<span class="go">([2, 0, 0], [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="IdealFlow.Network.IFN.out_neighbors">
<span class="sig-name descname"><span class="pre">out_neighbors</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">startNode</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">dict</span></span></span><a class="headerlink" href="#IdealFlow.Network.IFN.out_neighbors" title="Link to this definition"></a></dt>
<dd><p>Return the outgoing neighbors and their weights from the given start node.
(Successor)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>startNode</strong> (<em>str</em>)  The node for which outgoing neighbors are required.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><dl class="simple">
<dt>A dictionary where keys are neighboring nodes and values are edge weights.</dt><dd><p>Returns an empty dict if the node has no neighbors.</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>dict</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">IdealFlow.Network</span> <span class="k">as</span> <span class="nn">net</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="n">net</span><span class="o">.</span><span class="n">IFN</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">add_link</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">add_link</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">out_neighbors</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">)</span>
<span class="go">{&#39;b&#39;: 3, &#39;c&#39;: 5}</span>
</pre></div>
</div>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="IdealFlow.Network.IFN.out_weight">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">out_weight</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">tuple</span></em><a class="headerlink" href="#IdealFlow.Network.IFN.out_weight" title="Link to this definition"></a></dt>
<dd><p>Return the total outgoing weight of each node and a list of all nodes.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p><dl class="simple">
<dt>A tuple containing two lists:</dt><dd><ul class="simple">
<li><p>List of total outgoing weights for each node.</p></li>
<li><p>List of nodes corresponding to the weights.</p></li>
</ul>
</dd>
</dl>
</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>tuple</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">IdealFlow.Network</span> <span class="k">as</span> <span class="nn">net</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="n">net</span><span class="o">.</span><span class="n">IFN</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">add_link</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">add_link</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">out_weight</span>
<span class="go">([8, 0, 0], [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="IdealFlow.Network.IFN.overlay">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">overlay</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">net1</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#IdealFlow.Network.IFN" title="IdealFlow.Network.IFN"><span class="pre">IFN</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">net2</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#IdealFlow.Network.IFN" title="IdealFlow.Network.IFN"><span class="pre">IFN</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#IdealFlow.Network.IFN" title="IdealFlow.Network.IFN"><span class="pre">IFN</span></a></span></span><a class="headerlink" href="#IdealFlow.Network.IFN.overlay" title="Link to this definition"></a></dt>
<dd><p>Overlay net1 into net2, updating weights in net2 based on net1.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>net1</strong> (<a class="reference internal" href="#IdealFlow.Network.IFN" title="IdealFlow.Network.IFN"><em>IFN</em></a>)  The network to overlay. (smaller)</p></li>
<li><p><strong>net2</strong> (<a class="reference internal" href="#IdealFlow.Network.IFN" title="IdealFlow.Network.IFN"><em>IFN</em></a>)  The base network to overlay onto. (base - usually larger)</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The updated network with the overlay of net1.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="#IdealFlow.Network.IFN" title="IdealFlow.Network.IFN">IFN</a></p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">IdealFlow.Network</span> <span class="k">as</span> <span class="nn">net</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="n">net</span><span class="o">.</span><span class="n">IFN</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">base_net</span><span class="p">,</span> <span class="n">overlay_net</span> <span class="o">=</span> <span class="n">net</span><span class="o">.</span><span class="n">IFN</span><span class="p">(),</span> <span class="n">net</span><span class="o">.</span><span class="n">IFN</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">result_net</span> <span class="o">=</span> <span class="n">n</span><span class="o">.</span><span class="n">overlay</span><span class="p">(</span><span class="n">base_net</span><span class="p">,</span> <span class="n">overlay_net</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="IdealFlow.Network.IFN.parse_cycle">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">parse_cycle</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">cycle</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">list</span></span></span><a class="headerlink" href="#IdealFlow.Network.IFN.parse_cycle" title="Link to this definition"></a></dt>
<dd><p>Parses a cycle string into a list of node indices.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>cycle</strong> (<em>str</em>)  The cycle string.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A list of node indices representing the cycle.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>list</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">IdealFlow.Network</span> <span class="k">as</span> <span class="nn">net</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="n">net</span><span class="o">.</span><span class="n">IFN</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">parse_cycle</span><span class="p">(</span><span class="s1">&#39;abc&#39;</span><span class="p">)</span>
<span class="go">[0, 1, 2]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="IdealFlow.Network.IFN.parse_terms_to_dict">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">parse_terms_to_dict</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">signature</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">dict</span></span></span><a class="headerlink" href="#IdealFlow.Network.IFN.parse_terms_to_dict" title="Link to this definition"></a></dt>
<dd><p>Parses a signature into a dictionary with terms as keys and their coefficients as values.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>signature</strong> (<em>str</em>)  The cycle string where each term is a variable or has a coefficient.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A dictionary where keys are terms (variables) and values are their coefficients.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>dict</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">IdealFlow.Network</span> <span class="k">as</span> <span class="nn">net</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="n">net</span><span class="o">.</span><span class="n">IFN</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">parse_terms_to_dict</span><span class="p">(</span><span class="s1">&#39;2a + b + 3c&#39;</span><span class="p">)</span>
<span class="go">{&#39;a&#39;: 2, &#39;b&#39;: 1, &#39;c&#39;: 3}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">parse_terms_to_dict</span><span class="p">(</span><span class="s2">&quot;abc + 2bca + 5def&quot;</span><span class="p">)</span>
<span class="go">{&#39;abc&#39;: 1, &#39;bca&#39;: 2, &#39;def&#39;: 5}</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="IdealFlow.Network.IFN.path_distance">
<span class="sig-name descname"><span class="pre">path_distance</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">startNode</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">endNode</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">float</span></span></span><a class="headerlink" href="#IdealFlow.Network.IFN.path_distance" title="Link to this definition"></a></dt>
<dd><p>Calculate the total weight of the shortest path between startNode and endNode.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>startNode</strong> (<em>str</em>)  The starting node.</p></li>
<li><p><strong>endNode</strong> (<em>str</em>)  The target node.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The sum of weights along the shortest path.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">IdealFlow.Network</span> <span class="k">as</span> <span class="nn">net</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="n">net</span><span class="o">.</span><span class="n">IFN</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">add_link</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">add_link</span><span class="p">(</span><span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">,</span> <span class="mi">7</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">path_distance</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">)</span>
<span class="go">10</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">path_distance</span><span class="p">(</span><span class="s1">&#39;c&#39;</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">)</span>
<span class="go">0</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="IdealFlow.Network.IFN.path_length">
<span class="sig-name descname"><span class="pre">path_length</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">startNode</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">endNode</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">int</span></span></span><a class="headerlink" href="#IdealFlow.Network.IFN.path_length" title="Link to this definition"></a></dt>
<dd><p>Return the number of edges in the path if it forms a valid path, otherwise return 0.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>startNode</strong> (<em>str</em>)  The starting node.</p></li>
<li><p><strong>endNode</strong> (<em>str</em>)  The target node.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The number of edges in the shortest path, or 0 if not a path.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>int</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">IdealFlow.Network</span> <span class="k">as</span> <span class="nn">net</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="n">net</span><span class="o">.</span><span class="n">IFN</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">add_link</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">add_link</span><span class="p">(</span><span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">,</span> <span class="mi">7</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">path_length</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">)</span>
<span class="go">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">path_length</span><span class="p">(</span><span class="s1">&#39;c&#39;</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">)</span>
<span class="go">0</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="IdealFlow.Network.IFN.path_sum_weight">
<span class="sig-name descname"><span class="pre">path_sum_weight</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">path</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">float</span></span></span><a class="headerlink" href="#IdealFlow.Network.IFN.path_sum_weight" title="Link to this definition"></a></dt>
<dd><p>Return the sum of weights along the given path.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>path</strong> (<em>list</em>)  A sequence of nodes forming a path.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The sum of weights along the path.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">IdealFlow.Network</span> <span class="k">as</span> <span class="nn">net</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="n">net</span><span class="o">.</span><span class="n">IFN</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">add_link</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">add_link</span><span class="p">(</span><span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">path_sum_weight</span><span class="p">([</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">])</span>
<span class="go">3</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="IdealFlow.Network.IFN.permutations">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">permutations</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">N</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">list</span></span></span><a class="headerlink" href="#IdealFlow.Network.IFN.permutations" title="Link to this definition"></a></dt>
<dd><p>Generates all non-empty permutations of N letters.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>N</strong> (<em>int</em>)  The number of letters to permute.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The list of permutations.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>list of str</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">IdealFlow.Network</span> <span class="k">as</span> <span class="nn">net</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="n">net</span><span class="o">.</span><span class="n">IFN</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">permutations</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">[&#39;a&#39;, &#39;b&#39;, &#39;ab&#39;, &#39;ba&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">permutations</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="go">[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;ab&#39;, &#39;ac&#39;, &#39;ba&#39;, &#39;bc&#39;, &#39;ca&#39;, &#39;cb&#39;, &#39;abc&#39;, &#39;acb&#39;, &#39;bac&#39;, &#39;bca&#39;, &#39;cab&#39;, &#39;cba&#39;]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="IdealFlow.Network.IFN.premier_ifn">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">premier_ifn</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">C</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">list</span></span></span><a class="headerlink" href="#IdealFlow.Network.IFN.premier_ifn" title="Link to this definition"></a></dt>
<dd><p>Return the minimum integer IFN regardless of stochastic matrix.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>C</strong> (<em>list</em>)  The capacity matrix.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The premier IFN.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>list</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">IdealFlow.Network</span> <span class="k">as</span> <span class="nn">net</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">C</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="n">net</span><span class="o">.</span><span class="n">IFN</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">premier_flow</span> <span class="o">=</span> <span class="n">n</span><span class="o">.</span><span class="n">premier_ifn</span><span class="p">(</span><span class="n">C</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">premier_flow</span><span class="p">)</span>
<span class="go">[[0, 1], [1, 0]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="IdealFlow.Network.IFN.premier_signature">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">premier_signature</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">C</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">str</span></span></span><a class="headerlink" href="#IdealFlow.Network.IFN.premier_signature" title="Link to this definition"></a></dt>
<dd><p>Compute the premier signature for a given capacity matrix.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>C</strong> (<em>list</em><em> of </em><em>list</em><em> of </em><em>int/float</em>)  The capacity matrix.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The premier signature.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>str</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">IdealFlow.Network</span> <span class="k">as</span> <span class="nn">net</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="n">net</span><span class="o">.</span><span class="n">IFN</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">C</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">signature</span> <span class="o">=</span> <span class="n">n</span><span class="o">.</span><span class="n">premier_signature</span><span class="p">(</span><span class="n">C</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">signature</span><span class="p">)</span>
<span class="go">ab + a</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="IdealFlow.Network.IFN.query">
<span class="sig-name descname"><span class="pre">query</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sequence</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'min'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#IdealFlow.Network.IFN.query" title="Link to this definition"></a></dt>
<dd><p>Find a cycle path from a cloud node to a cloud node that contains the node sequence.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>sequence</strong> (<em>list</em><em> or </em><em>str</em>)  The sequence of nodes to include in the path.</p></li>
<li><p><strong>method</strong> (<em>str</em>)  min for minimum flow paths, max for maximum flow paths.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A tuple containing the path as a list of nodes and the probability.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>tuple</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">path</span><span class="p">,</span> <span class="n">probability</span> <span class="o">=</span> <span class="n">network</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="s1">&#39;ace&#39;</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;min&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Query result: Probability: </span><span class="si">{</span><span class="n">probability</span><span class="si">}</span><span class="s2">, Path: </span><span class="si">{</span><span class="n">path</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="IdealFlow.Network.IFN.query_cycle_limit">
<span class="sig-name descname"><span class="pre">query_cycle_limit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sequence</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'min'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_internal_cycle</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#IdealFlow.Network.IFN.query_cycle_limit" title="Link to this definition"></a></dt>
<dd><p>Find a cycle path from the cloud node to the cloud node that contains the node sequence,
limiting the number of internal cycles.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>sequence</strong> (<em>list</em><em> or </em><em>str</em>)  The sequence of nodes to include in the path.</p></li>
<li><p><strong>method</strong> (<em>str</em>)  The method to use for pathfinding (min, max, or dfs).</p></li>
<li><p><strong>max_internal_cycle</strong> (<em>int</em>)  The maximum number of internal cycles allowed in the path.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A tuple containing the the path as a list of nodes and average probability</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>tuple</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">IdealFlow.Network</span> <span class="k">as</span> <span class="nn">net</span>     <span class="c1"># import package.module as alias</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="n">net</span><span class="o">.</span><span class="n">IFN</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">adjList</span> <span class="o">=</span> <span class="p">{</span>
<span class="go">        &#39;a&#39;: {&#39;c&#39;: 1, &#39;d&#39;: 2},</span>
<span class="go">        &#39;b&#39;: {&#39;c&#39;: 1, &#39;e&#39;: 3, &#39;#Z#&#39;: 10},</span>
<span class="go">        &#39;c&#39;: {&#39;e&#39;: 5},</span>
<span class="go">        &#39;d&#39;: {&#39;c&#39;: 5},</span>
<span class="go">        &#39;e&#39;: {&#39;a&#39;: 3, &#39;b&#39;: 5},</span>
<span class="go">        &#39;#Z#&#39;: {&#39;a&#39;: 10, &#39;b&#39;: 10}  # Cloud node connections</span>
<span class="go">    }</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">set_data</span><span class="p">(</span><span class="n">adjList</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">path</span><span class="p">,</span> <span class="n">probability</span> <span class="o">=</span> <span class="n">n</span><span class="o">.</span><span class="n">query_cycle_limit</span><span class="p">(</span><span class="s1">&#39;ace&#39;</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;min&#39;</span><span class="p">,</span> <span class="n">max_internal_cycle</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Query result: Probability: </span><span class="si">{</span><span class="n">probability</span><span class="si">}</span><span class="s2">, Path: </span><span class="si">{</span><span class="n">path</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">path</span><span class="p">,</span> <span class="n">probability</span> <span class="o">=</span> <span class="n">nquery_cycle_limit</span><span class="p">(</span><span class="s1">&#39;ace&#39;</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;max&#39;</span><span class="p">,</span> <span class="n">max_internal_cycle</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Query result with max_internal_cycle=1: Probability: </span><span class="si">{</span><span class="n">probability</span><span class="si">}</span><span class="s2">, Path: </span><span class="si">{</span><span class="n">path</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="IdealFlow.Network.IFN.rand_capacity">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">rand_capacity</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">num_node</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">5</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_capacity</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">9</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#IdealFlow.Network.IFN.rand_capacity" title="Link to this definition"></a></dt>
<dd><p>Generate random capacity matrix for a given number of nodes.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>num_node</strong> (<em>int</em>)  Number of nodes.</p></li>
<li><p><strong>max_capacity</strong> (<em>int</em>)  Maximum capacity value.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The random capacity matrix.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>list of list of int</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">IdealFlow.Network</span> <span class="k">as</span> <span class="nn">net</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="n">net</span><span class="o">.</span><span class="n">IFN</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">rand_capacity</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
<span class="go">[[0, 7, 3, 0, 0], ...]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="IdealFlow.Network.IFN.rand_ifn_signature">
<span class="sig-name descname"><span class="pre">rand_ifn_signature</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">numNodes</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">5</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kappa</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">17</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#IdealFlow.Network.IFN.rand_ifn_signature" title="Link to this definition"></a></dt>
<dd><p>Generate a random cycle signature for an Ideal Flow Network (IFN) that meets the specified number of nodes and total flow.</p>
<p>This method constructs a cycle signature by randomly generating cycles and assigning coefficients to them,
ensuring that the total flow (sum of coefficients times cycle lengths) equals the specified kappa.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>numNodes</strong> (<em>int</em><em>, </em><em>optional</em>)  The number of nodes in the network. Default is 5.</p></li>
<li><p><strong>kappa</strong> (<em>int</em><em>, </em><em>optional</em>)  The total flow in the network. Default is 100.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The cycle signature as a string.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>str</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">IdealFlow.Network</span> <span class="k">as</span> <span class="nn">net</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="n">net</span><span class="o">.</span><span class="n">IFN</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">signature</span> <span class="o">=</span> <span class="n">n</span><span class="o">.</span><span class="n">findIFNsignature</span><span class="p">(</span><span class="n">numNodes</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">kappa</span><span class="o">=</span><span class="mi">50</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">signature</span><span class="p">)</span>
<span class="go">abcde + 6abce + 4bcd + 2ade</span>
</pre></div>
</div>
<p>The output is a cycle signature string where each term represents a cycle,
and the coefficient indicates the number of times the cycle occurs in the network.</p>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>The method ensures that the total flow does not exceed the specified kappa.</p></li>
<li><p>It avoids adding self-loops (cycles of length 1) unless necessary.</p></li>
</ul>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="IdealFlow.Network.IFN.rand_int">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">rand_int</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mR</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mC</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_val</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">10</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">prob</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0.8</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">ndarray</span></span></span><a class="headerlink" href="#IdealFlow.Network.IFN.rand_int" title="Link to this definition"></a></dt>
<dd><p>Generate a random integer matrix with biased zero entries.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>mR</strong> (<em>int</em>)  Number of rows.</p></li>
<li><p><strong>mC</strong> (<em>int</em>)  Number of columns.</p></li>
<li><p><strong>max_val</strong> (<em>int</em>)  Maximum value for non-zero entries. Defaults to 10.</p></li>
<li><p><strong>prob</strong> (<em>float</em>)  Probability of zeros. Defaults to 0.8.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A random integer matrix.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>np.ndarray</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">IdealFlow.Network</span> <span class="k">as</span> <span class="nn">net</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="n">net</span><span class="o">.</span><span class="n">IFN</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">n</span><span class="o">.</span><span class="n">rand_int</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">max_val</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">prob</span><span class="o">=</span><span class="mf">0.7</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
<span class="go">[[0 3 0]</span>
<span class="go"> [4 0 2]</span>
<span class="go"> [0 0 5]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="IdealFlow.Network.IFN.rand_irreducible">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">rand_irreducible</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">num_nodes</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">5</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_links</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">8</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">ndarray</span></span></span><a class="headerlink" href="#IdealFlow.Network.IFN.rand_irreducible" title="Link to this definition"></a></dt>
<dd><p>Generate a random irreducible matrix.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>num_nodes</strong> (<em>int</em>)  Number of nodes.</p></li>
<li><p><strong>num_links</strong> (<em>int</em>)  Number of links.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The random irreducible matrix.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>np.ndarray</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">IdealFlow.Network</span> <span class="k">as</span> <span class="nn">net</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="n">net</span><span class="o">.</span><span class="n">IFN</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">n</span><span class="o">.</span><span class="n">rand_irreducible</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="go">[[0 1 0]</span>
<span class="go"> [1 0 1]</span>
<span class="go"> [1 1 0]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="IdealFlow.Network.IFN.rand_permutation_eye">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">rand_permutation_eye</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">5</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">ndarray</span></span></span><a class="headerlink" href="#IdealFlow.Network.IFN.rand_permutation_eye" title="Link to this definition"></a></dt>
<dd><p>Generate a random permutation of the identity matrix.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>n</strong> (<em>int</em>)  The size of the matrix.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The permuted identity matrix.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>np.ndarray</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">IdealFlow.Network</span> <span class="k">as</span> <span class="nn">net</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="n">net</span><span class="o">.</span><span class="n">IFN</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">permuted_eye</span> <span class="o">=</span> <span class="n">n</span><span class="o">.</span><span class="n">rand_permutation_eye</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">permuted_eye</span><span class="p">)</span>
<span class="go">[[0. 1. 0.]</span>
<span class="go"> [1. 0. 0.]</span>
<span class="go"> [0. 0. 1.]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="IdealFlow.Network.IFN.rand_stochastic">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">rand_stochastic</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">ndarray</span></span></span><a class="headerlink" href="#IdealFlow.Network.IFN.rand_stochastic" title="Link to this definition"></a></dt>
<dd><p>Generate a random row-stochastic matrix of size n.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>n</strong> (<em>int</em>)  Size of the square matrix.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The random row-stochastic matrix.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>np.ndarray</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">IdealFlow.Network</span> <span class="k">as</span> <span class="nn">net</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="n">net</span><span class="o">.</span><span class="n">IFN</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">S</span> <span class="o">=</span> <span class="n">n</span><span class="o">.</span><span class="n">rand_stochastic</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">S</span><span class="p">)</span>
<span class="go">[[0.2 0.3 0.5]</span>
<span class="go"> [0.4 0.2 0.4]</span>
<span class="go"> [0.3 0.3 0.4]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="IdealFlow.Network.IFN.random_cycle_from">
<span class="sig-name descname"><span class="pre">random_cycle_from</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">startEndNode</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">allow_internal_cycles</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_internal_cycles</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">inf</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">list</span></span></span><a class="headerlink" href="#IdealFlow.Network.IFN.random_cycle_from" title="Link to this definition"></a></dt>
<dd><p>Perform a random walk that starts and ends at the specified startEndNode, forming a cycle.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>startEndNode</strong> (<em>str</em>)  The starting and ending node of the cycle.</p></li>
<li><p><strong>allow_internal_cycles</strong> (<em>bool</em><em>, </em><em>optional</em>)  If True (default), the walk allows internal cycles (cycles from nodes other than startEndNode).</p></li>
<li><p><strong>max_internal_cycles</strong> (<em>int</em><em>, </em><em>optional</em>)  Maximum number of allowed internal cycles. Defaults to infinity if not specified.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A list of nodes visited during the random walk that forms a cycle. If no cycle can be formed, it returns an empty list.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>list</p>
</dd>
</dl>
<dl class="simple">
<dt>Stochastic Behavior:</dt><dd><p>The next node in the walk is chosen probabilistically based on the weights of the outgoing edges.
Nodes with higher edge weights have a greater chance of being chosen, making the walk biased toward those edges.</p>
</dd>
<dt>Special Cases:</dt><dd><p>If the network contains no cycles, the method will return an empty list, as no cycle can be formed.
If only one cycle exists in the network, the walk will discover that cycle.
In strongly connected networks, the random walk is more likely to find cycles, as all nodes are reachable from any other node.</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">IdealFlow.Network</span> <span class="k">as</span> <span class="nn">net</span>     <span class="c1"># import package.module as alias</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="n">net</span><span class="o">.</span><span class="n">IFN</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">add_link</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">add_link</span><span class="p">(</span><span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">add_link</span><span class="p">(</span><span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;d&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">add_link</span><span class="p">(</span><span class="s1">&#39;d&#39;</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">add_link</span><span class="p">(</span><span class="s1">&#39;d&#39;</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">random_cycle_from</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">))</span>
<span class="go">[&#39;a&#39;, &#39;b&#39;, &#39;d&#39;, &#39;a&#39;]</span>
<span class="go">[]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">add_link</span><span class="p">(</span><span class="s1">&#39;c&#39;</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">random_cycle_from</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="n">allow_internal_cycles</span><span class="o">=</span><span class="kc">False</span><span class="p">))</span> <span class="c1"># Disallowing Internal Cycles</span>
<span class="go">[&#39;a&#39;, &#39;b&#39;, &#39;d&#39;, &#39;c&#39;, &#39;a&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">random_cycle_from</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="n">allow_internal_cycles</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">max_internal_cycles</span><span class="o">=</span><span class="mi">2</span><span class="p">))</span> <span class="c1"># Allowing Internal Cycles with a Limit</span>
<span class="go">[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;a&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">random_cycle_from</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="n">allow_internal_cycles</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span> <span class="c1"># Unrestricted Internal Cycles</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="IdealFlow.Network.IFN.random_ideal_flow_matrix">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">random_ideal_flow_matrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">N</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kappa</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">array</span></span></span><a class="headerlink" href="#IdealFlow.Network.IFN.random_ideal_flow_matrix" title="Link to this definition"></a></dt>
<dd><p>Generate random irreducible ideal flow matrix.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>N</strong> (<em>int</em>)  Size of the matrix (number of nodes).</p></li>
<li><p><strong>kappa</strong> (<em>float</em>)  Scaling factor for the ideal flow. Default is 1.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Random irreducible ideal flow matrix.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>np.array</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">IdealFlow.Network</span> <span class="k">as</span> <span class="nn">net</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="n">net</span><span class="o">.</span><span class="n">IFN</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">result</span> <span class="o">=</span> <span class="n">n</span><span class="o">.</span><span class="n">random_ideal_flow_matrix</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">kappa</span><span class="o">=</span><span class="mi">27</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
<span class="go">[[...], [...], [...]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="IdealFlow.Network.IFN.random_ifn">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">random_ifn</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">num_nodes</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">5</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">total_flow</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">list</span></span></span><a class="headerlink" href="#IdealFlow.Network.IFN.random_ifn" title="Link to this definition"></a></dt>
<dd><p>Generate a random ideal flow matrix with a given number of nodes and total flow based on network signature.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>num_nodes</strong> (<em>int</em>)  Number of nodes. Default is 5.</p></li>
<li><p><strong>total_flow</strong> (<em>float</em>)  Total flow. Default is 1.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The ideal flow network.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>list</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">IdealFlow.Network</span> <span class="k">as</span> <span class="nn">net</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="n">net</span><span class="o">.</span><span class="n">IFN</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">random_network</span> <span class="o">=</span> <span class="n">n</span><span class="o">.</span><span class="n">random_ifn</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">random_network</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="IdealFlow.Network.IFN.random_irreducible_stochastic">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">random_irreducible_stochastic</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">N</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#IdealFlow.Network.IFN.random_irreducible_stochastic" title="Link to this definition"></a></dt>
<dd><p>Generate random irreducible stochastic matrix.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>N</strong> (<em>int</em>)  Size of the matrix.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The random stochastic matrix.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>list of list of float</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">IdealFlow.Network</span> <span class="k">as</span> <span class="nn">net</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="n">net</span><span class="o">.</span><span class="n">IFN</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">random_irreducible_stochastic</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="IdealFlow.Network.IFN.random_walk_cycle">
<span class="sig-name descname"><span class="pre">random_walk_cycle</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">start_end_node</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">list</span></span></span><a class="headerlink" href="#IdealFlow.Network.IFN.random_walk_cycle" title="Link to this definition"></a></dt>
<dd><p>Perform a random walk through nodes in a cycle starting and ending at the same node.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>start_end_node</strong> (<em>str</em>)  The node from which the random cycle starts and ends.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>List of nodes visited during the random walk cycle.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>list</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">IdealFlow.Network</span> <span class="k">as</span> <span class="nn">net</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="n">net</span><span class="o">.</span><span class="n">IFN</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">result</span> <span class="o">=</span> <span class="n">n</span><span class="o">.</span><span class="n">random_walk_cycle</span><span class="p">(</span><span class="s1">&#39;A&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
<span class="go">[&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;A&#39;]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="IdealFlow.Network.IFN.random_walk_from">
<span class="sig-name descname"><span class="pre">random_walk_from</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">startNode</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">length</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">allow_internal_cycles</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_internal_cycles</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">inf</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">list</span></span></span><a class="headerlink" href="#IdealFlow.Network.IFN.random_walk_from" title="Link to this definition"></a></dt>
<dd><p>Perform a stochastic random walk from the given startNode, either until reaching a sink node
(a node with no outgoing edges) or for a specified number of steps. The next node is chosen
probabilistically based on the weights of the outgoing edges from the current node.</p>
<dl class="simple">
<dt>Internal Cycle Handling:</dt><dd><p>If <cite>allow_internal_cycles</cite> is False, the walk will terminate upon revisiting any node.
If <cite>allow_internal_cycles</cite> is True, the walk can revisit nodes, but the number of internal cycles is limited by <cite>max_internal_cycles</cite>.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>startNode</strong> (<em>str</em>)  The starting node.</p></li>
<li><p><strong>length</strong> (<em>int</em>)  The maximum number of steps in the random walk.</p></li>
<li><p><strong>allow_internal_cycles</strong> (<em>bool</em>)  Whether to allow internal cycles (revisiting nodes) during the walk. Defaults to True.</p></li>
<li><p><strong>max_internal_cycles</strong> (<em>int</em>)  The maximum number of internal cycles allowed. Defaults to infinity.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A list of nodes visited during the random walk. The walk will stop if it reaches a sink node, if the specified length is reached, or if the number of allowed internal cycles is exceeded.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>list</p>
</dd>
</dl>
<dl class="simple">
<dt>Stochastic Behavior:</dt><dd><p>If the current node has multiple outgoing neighbors, the next node is chosen based on the probability distribution proportional to the weights of the edges.
Nodes with higher edge weights are more likely to be chosen than those with lower weights.</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">IdealFlow.Network</span> <span class="k">as</span> <span class="nn">net</span>     <span class="c1"># import package.module as alias</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="n">net</span><span class="o">.</span><span class="n">IFN</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">add_link</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">add_link</span><span class="p">(</span><span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">add_link</span><span class="p">(</span><span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;d&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">add_link</span><span class="p">(</span><span class="s1">&#39;d&#39;</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">add_link</span><span class="p">(</span><span class="s1">&#39;d&#39;</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">random_walk_from</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="mi">7</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># n.show()</span>
<span class="go">[&#39;a&#39;, &#39;b&#39;, &#39;d&#39;, &#39;a&#39;, &#39;b&#39;, &#39;c&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">random_walk_from</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="mi">7</span><span class="p">))</span>
<span class="go">[&#39;a&#39;, &#39;b&#39;, &#39;d&#39;, &#39;a&#39;, &#39;b&#39;, &#39;d&#39;, &#39;a&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">random_walk_from</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="mi">7</span><span class="p">))</span>
<span class="go">[&#39;a&#39;, &#39;b&#39;, &#39;d&#39;, &#39;c&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">random_walk_from</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="n">allow_internal_cycles</span><span class="o">=</span><span class="kc">False</span><span class="p">))</span>
<span class="go">[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">random_walk_from</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="n">max_internal_cycles</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
<span class="go">[&#39;a&#39;, &#39;b&#39;, &#39;d&#39;, &#39;a&#39;, &#39;b&#39;]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="IdealFlow.Network.IFN.random_walk_matrix">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">random_walk_matrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">m_capacity</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">array</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">arr_name</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">prev_index</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">tuple</span></span></span><a class="headerlink" href="#IdealFlow.Network.IFN.random_walk_matrix" title="Link to this definition"></a></dt>
<dd><p>Perform a random walk on a Markov transition matrix.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>m_capacity</strong> (<em>np.array</em>)  The Markov transition matrix.</p></li>
<li><p><strong>arr_name</strong> (<em>list</em><em> of </em><em>str</em>)  List of node names corresponding to the rows/columns of the matrix.</p></li>
<li><p><strong>prev_index</strong> (<em>int</em>)  The index of the previous node in the walk.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The next node name and its index.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>tuple</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">IdealFlow.Network</span> <span class="k">as</span> <span class="nn">net</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="n">net</span><span class="o">.</span><span class="n">IFN</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">markov_matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">arr_name</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;B&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">next_node</span><span class="p">,</span> <span class="n">next_index</span> <span class="o">=</span> <span class="n">n</span><span class="o">.</span><span class="n">random_walk_matrix</span><span class="p">(</span><span class="n">markov_matrix</span><span class="p">,</span> <span class="n">arr_name</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">next_node</span><span class="p">,</span> <span class="n">next_index</span><span class="p">)</span>
<span class="go">B 1</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="IdealFlow.Network.IFN.random_walk_nodes">
<span class="sig-name descname"><span class="pre">random_walk_nodes</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">start_node</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">length</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">list</span></span></span><a class="headerlink" href="#IdealFlow.Network.IFN.random_walk_nodes" title="Link to this definition"></a></dt>
<dd><p>Perform a random walk through nodes starting from a specific node.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>start_node</strong> (<em>str</em>)  The starting node for the random walk.</p></li>
<li><p><strong>length</strong> (<em>int</em>)  The number of steps to walk. Default is 1.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>List of nodes visited during the random walk.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>list</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">IdealFlow.Network</span> <span class="k">as</span> <span class="nn">net</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="n">net</span><span class="o">.</span><span class="n">IFN</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">result</span> <span class="o">=</span> <span class="n">n</span><span class="o">.</span><span class="n">random_walk_nodes</span><span class="p">(</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="n">length</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
<span class="go">[&#39;A&#39;, &#39;B&#39;, &#39;C&#39;]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="IdealFlow.Network.IFN.read_csv">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">read_csv</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fName</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">list</span></span></span><a class="headerlink" href="#IdealFlow.Network.IFN.read_csv" title="Link to this definition"></a></dt>
<dd><p>Read a CSV file and return a 2D array.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>fName</strong> (<em>str</em>)  The name of the CSV file to read.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A 2D array representing the content of the CSV file.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>list</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">IdealFlow.Network</span> <span class="k">as</span> <span class="nn">net</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="n">net</span><span class="o">.</span><span class="n">IFN</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">=</span> <span class="n">n</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="s1">&#39;data.csv&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
<span class="go">[[&#39;1&#39;, &#39;2&#39;], [&#39;3&#39;, &#39;4&#39;]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="IdealFlow.Network.IFN.reduce_link_flow">
<span class="sig-name descname"><span class="pre">reduce_link_flow</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">startNode</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">endNode</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#IdealFlow.Network.IFN.reduce_link_flow" title="Link to this definition"></a></dt>
<dd><p>Reduces the flow of a link by 1. If the flow reaches zero or below, the link is deleted.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>startNode</strong> (<em>str</em>)  The starting node.</p></li>
<li><p><strong>endNode</strong> (<em>str</em>)  The ending node.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">IdealFlow.Network</span> <span class="k">as</span> <span class="nn">net</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="n">net</span><span class="o">.</span><span class="n">IFN</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">add_link</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">reduce_link_flow</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">get_link_flow</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">))</span>
<span class="go">nan</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="IdealFlow.Network.IFN.reindex">
<span class="sig-name descname"><span class="pre">reindex</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#IdealFlow.Network.IFN.reindex" title="Link to this definition"></a></dt>
<dd><p>Sort the nodes and standardize the adjacency list.</p>
<p>This operation may take a long time for large datasets.</p>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">IdealFlow.Network</span> <span class="k">as</span> <span class="nn">net</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="n">net</span><span class="o">.</span><span class="n">IFN</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">reindex</span><span class="p">()</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="IdealFlow.Network.IFN.relabel_signature">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">relabel_signature</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">net_signature</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">node_mapping</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">dict</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">str</span></span></span><a class="headerlink" href="#IdealFlow.Network.IFN.relabel_signature" title="Link to this definition"></a></dt>
<dd><p>Relabel a network signature using a node mapping.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>net_signature</strong> (<em>str</em>)  The network signature.</p></li>
<li><p><strong>node_mapping</strong> (<em>dict</em>)  The node mapping.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The relabeled signature.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>str</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#IdealFlow.Network.IFN.create_node_mapping" title="IdealFlow.Network.IFN.create_node_mapping"><code class="xref py py-meth docutils literal notranslate"><span class="pre">create_node_mapping()</span></code></a>
<a class="reference internal" href="#IdealFlow.Network.IFN.reverse_relabel_signature" title="IdealFlow.Network.IFN.reverse_relabel_signature"><code class="xref py py-meth docutils literal notranslate"><span class="pre">reverse_relabel_signature()</span></code></a></p>
</div>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">IdealFlow.Network</span> <span class="k">as</span> <span class="nn">net</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="n">net</span><span class="o">.</span><span class="n">IFN</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">signature</span> <span class="o">=</span> <span class="s2">&quot;abc + bcd&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">node_mapping</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;a&#39;</span><span class="p">:</span> <span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">:</span> <span class="s1">&#39;y&#39;</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">:</span> <span class="s1">&#39;z&#39;</span><span class="p">}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">relabeled</span> <span class="o">=</span> <span class="n">n</span><span class="o">.</span><span class="n">relabel_signature</span><span class="p">(</span><span class="n">signature</span><span class="p">,</span> <span class="n">node_mapping</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">relabeled</span><span class="p">)</span>  <span class="c1"># Output: &quot;xyz + yzd&quot;</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="IdealFlow.Network.IFN.reverse_network">
<span class="sig-name descname"><span class="pre">reverse_network</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#IdealFlow.Network.IFN" title="IdealFlow.Network.IFN"><span class="pre">IFN</span></a></span></span><a class="headerlink" href="#IdealFlow.Network.IFN.reverse_network" title="Link to this definition"></a></dt>
<dd><p>Return a new network with the direction of all links reversed.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>A new network with reversed links.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference internal" href="#IdealFlow.Network.IFN" title="IdealFlow.Network.IFN">IFN</a></p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">IdealFlow.Network</span> <span class="k">as</span> <span class="nn">net</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="n">net</span><span class="o">.</span><span class="n">IFN</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">reversed_net</span> <span class="o">=</span> <span class="n">n</span><span class="o">.</span><span class="n">reverse_network</span><span class="p">()</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="IdealFlow.Network.IFN.reverse_relabel_signature">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">reverse_relabel_signature</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">relabeled_signature</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">node_mapping</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">dict</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">str</span></span></span><a class="headerlink" href="#IdealFlow.Network.IFN.reverse_relabel_signature" title="Link to this definition"></a></dt>
<dd><p>Reverse relabel a network signature using a node mapping.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>relabeled_signature</strong> (<em>str</em>)  The relabeled signature.</p></li>
<li><p><strong>node_mapping</strong> (<em>dict</em>)  The node mapping.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The original signature.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>str</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#IdealFlow.Network.IFN.create_node_mapping" title="IdealFlow.Network.IFN.create_node_mapping"><code class="xref py py-meth docutils literal notranslate"><span class="pre">create_node_mapping()</span></code></a>
<a class="reference internal" href="#IdealFlow.Network.IFN.relabel_signature" title="IdealFlow.Network.IFN.relabel_signature"><code class="xref py py-meth docutils literal notranslate"><span class="pre">relabel_signature()</span></code></a></p>
</div>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">IdealFlow.Network</span> <span class="k">as</span> <span class="nn">net</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="n">net</span><span class="o">.</span><span class="n">IFN</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">relabeled</span> <span class="o">=</span> <span class="s2">&quot;xyz + yzd&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">node_mapping</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;x&#39;</span><span class="p">:</span> <span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">:</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;z&#39;</span><span class="p">:</span> <span class="s1">&#39;c&#39;</span><span class="p">}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">original</span> <span class="o">=</span> <span class="n">n</span><span class="o">.</span><span class="n">reverse_relabel_signature</span><span class="p">(</span><span class="n">relabeled</span><span class="p">,</span> <span class="n">node_mapping</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">original</span><span class="p">)</span>  <span class="c1"># Output: &quot;abc + bcd&quot;</span>
</pre></div>
</div>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="IdealFlow.Network.IFN.row_stochastic">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">row_stochastic</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">dict</span></em><a class="headerlink" href="#IdealFlow.Network.IFN.row_stochastic" title="Link to this definition"></a></dt>
<dd><p>Convert the adjacency list to a row-stochastic form, where values represent the link probability out of each node.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>A row-stochastic adjacency list.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>dict</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">IdealFlow.Network</span> <span class="k">as</span> <span class="nn">net</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="n">net</span><span class="o">.</span><span class="n">IFN</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">add_link</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">add_link</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">row_stochastic</span>
<span class="go">{&#39;a&#39;: {&#39;b&#39;: 0.6, &#39;c&#39;: 0.4}, &#39;b&#39;: {}, &#39;c&#39;: {}}</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="IdealFlow.Network.IFN.save">
<span class="sig-name descname"><span class="pre">save</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fileName</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#IdealFlow.Network.IFN.save" title="Link to this definition"></a></dt>
<dd><p>Save the adjacency list to a JSON file.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>fileName</strong> (<em>str</em>)  The name of the file to save the data.</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">IdealFlow.Network</span> <span class="k">as</span> <span class="nn">net</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="n">net</span><span class="o">.</span><span class="n">IFN</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="s1">&#39;network.json&#39;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="IdealFlow.Network.IFN.save_adj_list">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">save_adj_list</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">adjL</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">dict</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">filename</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#IdealFlow.Network.IFN.save_adj_list" title="Link to this definition"></a></dt>
<dd><p>Save an adjacency list to a JSON file.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>adjL</strong> (<em>dict</em>)  The adjacency list.</p></li>
<li><p><strong>filename</strong> (<em>str</em>)  The name of the file to save to.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">IdealFlow.Network</span> <span class="k">as</span> <span class="nn">net</span>
<span class="go">    &gt;&gt;&gt; n = net.IFN()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">adjL</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;a&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;b&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">},</span> <span class="s1">&#39;b&#39;</span><span class="p">:</span> <span class="p">{}}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">save_adj_list</span><span class="p">(</span><span class="n">adjL</span><span class="p">,</span> <span class="s1">&#39;adj_list.json&#39;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="IdealFlow.Network.IFN.set_data">
<span class="sig-name descname"><span class="pre">set_data</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">adjList</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#IdealFlow.Network.IFN.set_data" title="Link to this definition"></a></dt>
<dd><p>Replaces the internal data structure of the network with the given adjacency list.</p>
<p>This method updates the internal adjacency list representation, the list of nodes,
and the number of nodes in the network. The adjacency list represents the network
structure where each key corresponds to a node, and the associated value is a list
of nodes connected to that key node.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>adjList</strong> (<em>dict</em>)  A dictionary representing the adjacency list of the network,
where keys are node identifiers and values are lists of neighboring nodes.</p>
</dd>
</dl>
<p>Example:
&gt;&gt;&gt; import IdealFlow.Network as net
&gt;&gt;&gt; n = net.IFN()
&gt;&gt;&gt; adjList = {a: {b: 1, c: 3}, b: {c:2}, c: {a:5}}
&gt;&gt;&gt; n.set_data(adjList)
&gt;&gt;&gt; print(n)
{a: {b: 1, c: 3}, b: {c: 2}, c: {a: 5}}</p>
<dl class="simple">
<dt>Side Effects:</dt><dd><dl class="simple">
<dt>Updates the following internal attributes:</dt><dd><ul class="simple">
<li><p>self.adjList: Stores the provided adjacency list.</p></li>
<li><p>self.listNodes: Stores the list of nodes derived from the adjacency list.</p></li>
<li><p>self.numNodes: Stores the number of nodes in the updated network.</p></li>
</ul>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="IdealFlow.Network.IFN.set_link_weight">
<span class="sig-name descname"><span class="pre">set_link_weight</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">startNode</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">endNode</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weight</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#IdealFlow.Network.IFN.set_link_weight" title="Link to this definition"></a></dt>
<dd><p>Sets the weight of a link directly. If the link does not exist, it is created.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>startNode</strong> (<em>str</em>)  The starting node.</p></li>
<li><p><strong>endNode</strong> (<em>str</em>)  The ending node.</p></li>
<li><p><strong>weight</strong> (<em>float</em>)  The weight to set.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">IdealFlow.Network</span> <span class="k">as</span> <span class="nn">net</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="n">net</span><span class="o">.</span><span class="n">IFN</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">set_link_weight</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">get_link_flow</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">))</span>
<span class="go">3.0</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="IdealFlow.Network.IFN.set_link_weight_plus_1">
<span class="sig-name descname"><span class="pre">set_link_weight_plus_1</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">startNode</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">endNode</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#IdealFlow.Network.IFN.set_link_weight_plus_1" title="Link to this definition"></a></dt>
<dd><p>Increments the weight of a link by 1. If the link does not exist, it is created with weight 1.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>startNode</strong> (<em>str</em>)  The starting node.</p></li>
<li><p><strong>endNode</strong> (<em>str</em>)  The ending node.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">IdealFlow.Network</span> <span class="k">as</span> <span class="nn">net</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="n">net</span><span class="o">.</span><span class="n">IFN</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">set_link_weight_plus_1</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">get_link_flow</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">))</span>
<span class="go">1.0</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="IdealFlow.Network.IFN.set_matrix">
<span class="sig-name descname"><span class="pre">set_matrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">M</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">listNode</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">[]</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#IdealFlow.Network.IFN.set_matrix" title="Link to this definition"></a></dt>
<dd><p>Replace the adjacency list with the provided matrix.
This is useful if we use matrices in computation and
want to put the matrix into network</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>M</strong> (<em>list</em>)  Adjacency matrix to set.</p></li>
<li><p><strong>listNode</strong> (<em>list</em>)  List of node names. Defaults to generating Excel-like labels.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">IdealFlow.Network</span> <span class="k">as</span> <span class="nn">net</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="n">net</span><span class="o">.</span><span class="n">IFN</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">matrix</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">set_matrix</span><span class="p">(</span><span class="n">matrix</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="IdealFlow.Network.IFN.set_path">
<span class="sig-name descname"><span class="pre">set_path</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">trajectory</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">delta_flow</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#IdealFlow.Network.IFN.set_path" title="Link to this definition"></a></dt>
<dd><p>Set a path in the network, updating the link weight by flow if it exists or creating the link with weight = 1 if it does not exist.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>trajectory</strong> (<em>list</em>)  A sequence of nodes to set as a path.</p></li>
<li><p><strong>delta_flow</strong> (<em>float</em>)  The additional weight of the links alongthe path. Defaults to 1.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>None</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">IdealFlow.Network</span> <span class="k">as</span> <span class="nn">net</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="n">net</span><span class="o">.</span><span class="n">IFN</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">add_link</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">set_path</span><span class="p">([</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">],</span> <span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">adjList</span>
<span class="go">{&#39;a&#39;: {&#39;b&#39;: 4}, &#39;b&#39;: {&#39;c&#39;: 3}, &#39;c&#39;: {}}</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="IdealFlow.Network.IFN.shortest_path">
<span class="sig-name descname"><span class="pre">shortest_path</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">startNode</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">endNode</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">list</span></span></span><a class="headerlink" href="#IdealFlow.Network.IFN.shortest_path" title="Link to this definition"></a></dt>
<dd><p>Find the shortest path (minimum number of links) between startNode and endNode.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>startNode</strong> (<em>str</em>)  The starting node.</p></li>
<li><p><strong>endNode</strong> (<em>str</em>)  The target node.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The shortest path from startNode to endNode.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>list</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">IdealFlow.Network</span> <span class="k">as</span> <span class="nn">net</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="n">net</span><span class="o">.</span><span class="n">IFN</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">add_link</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">add_link</span><span class="p">(</span><span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">shortest_path</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">)</span>
<span class="go">[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="IdealFlow.Network.IFN.show">
<span class="sig-name descname"><span class="pre">show</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">layout</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">'Planar'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mNode</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">arrThreshold</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">routes</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">DiGraph</span></span></span><a class="headerlink" href="#IdealFlow.Network.IFN.show" title="Link to this definition"></a></dt>
<dd><p>Visualizes the network using matplotlib and NetworkX.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>layout</strong> (<em>str</em><em>, </em><em>optional</em>)  The layout of the graph visualization. Options include:
Bipartite, Circular, Fruchterman, Kawai, Planar, Random,
Shell, Spectral, Spiral, Spring. Defaults to Planar.</p></li>
<li><p><strong>mNode</strong> (<em>list</em><em>, </em><em>optional</em>)  Custom positions for nodes, each row should be [node_id, x, y].</p></li>
<li><p><strong>arrThreshold</strong> (<em>list</em><em>, </em><em>optional</em>)  Thresholds for edge weights to determine the edge color.
Format: [low_threshold, high_threshold].</p></li>
<li><p><strong>routes</strong> (<em>list</em><em>, </em><em>optional</em>)  A list of routes, where each route is a list of node IDs.
Edges in these routes are highlighted in red.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The directed graph representing the IFN.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>nx.DiGraph</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">IdealFlow.Network</span> <span class="k">as</span> <span class="nn">net</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">adjList</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;a&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;b&#39;</span><span class="p">:</span> <span class="mf">1.5</span><span class="p">},</span> <span class="s1">&#39;b&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;c&#39;</span><span class="p">:</span> <span class="mf">0.7</span><span class="p">},</span> <span class="s1">&#39;c&#39;</span><span class="p">:</span> <span class="p">{}}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="n">net</span><span class="o">.</span><span class="n">IFN</span><span class="p">(</span><span class="n">adjList</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">show</span><span class="p">(</span><span class="n">layout</span><span class="o">=</span><span class="s1">&#39;Planar&#39;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="IdealFlow.Network.IFN.signature_coef_to_1">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">signature_coef_to_1</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">net_signature</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">str</span></span></span><a class="headerlink" href="#IdealFlow.Network.IFN.signature_coef_to_1" title="Link to this definition"></a></dt>
<dd><p>Convert all network signature coefficients to one.
Internally, it also canonize the cycle terms.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>net_signature</strong> (<em>str</em>)  The network signature.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The converted signature with all coefficients set to one.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>str</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">IdealFlow.Network</span> <span class="k">as</span> <span class="nn">net</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="n">net</span><span class="o">.</span><span class="n">IFN</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">signature</span> <span class="o">=</span> <span class="s2">&quot;2bca + 3fde&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">result</span> <span class="o">=</span> <span class="n">n</span><span class="o">.</span><span class="n">signature_coef_to_1</span><span class="p">(</span><span class="n">signature</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>  <span class="c1"># Output: &quot;abc + def&quot;</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="IdealFlow.Network.IFN.signature_to_adj_list">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">signature_to_adj_list</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">signature</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">is_cycle</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">dict</span></span></span><a class="headerlink" href="#IdealFlow.Network.IFN.signature_to_adj_list" title="Link to this definition"></a></dt>
<dd><p>Convert a network signature into an adjacency list.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>signature</strong> (<em>str</em>)  The network signature.</p></li>
<li><p><strong>is_cycle</strong> (<em>bool</em>)  Whether the signature represents a cycle (default is True).</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The adjacency list representation of the signature.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>dict</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">IdealFlow.Network</span> <span class="k">as</span> <span class="nn">net</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="n">net</span><span class="o">.</span><span class="n">IFN</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">signature_to_adj_list</span><span class="p">(</span><span class="s2">&quot;abc&quot;</span><span class="p">)</span>
<span class="go">{&#39;a&#39;: {&#39;b&#39;: 1.0}, &#39;b&#39;: {&#39;c&#39;: 1.0}, &#39;c&#39;: {&#39;a&#39;: 1.0}}</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="IdealFlow.Network.IFN.signature_to_coef_flow">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">signature_to_coef_flow</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">cycle_signature</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">float</span></span></span><a class="headerlink" href="#IdealFlow.Network.IFN.signature_to_coef_flow" title="Link to this definition"></a></dt>
<dd><p>Compute the coefficient of flow of a cycle signature.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>cycle_signature</strong> (<em>str</em>)  The cycle signature.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The coefficient of flow.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">IdealFlow.Network</span> <span class="k">as</span> <span class="nn">net</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="n">net</span><span class="o">.</span><span class="n">IFN</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">signature_to_coef_flow</span><span class="p">(</span><span class="s2">&quot;abc + def&quot;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="IdealFlow.Network.IFN.signature_to_column_stochastic">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">signature_to_column_stochastic</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">cycle_signature</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">is_cycle</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">dict</span></span></span><a class="headerlink" href="#IdealFlow.Network.IFN.signature_to_column_stochastic" title="Link to this definition"></a></dt>
<dd><p>Convert cycle signature to a column stochastic adjacency list.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>cycle_signature</strong> (<em>str</em>)  The cycle signature.</p></li>
<li><p><strong>is_cycle</strong> (<em>bool</em>)  Whether the signature represents a cycle.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The column stochastic adjacency list.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>dict</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">IdealFlow.Network</span> <span class="k">as</span> <span class="nn">net</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="n">net</span><span class="o">.</span><span class="n">IFN</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">signature_to_column_stochastic</span><span class="p">(</span><span class="s2">&quot;abc&quot;</span><span class="p">)</span>
<span class="go">{&#39;a&#39;: {&#39;b&#39;: 1.0}, &#39;b&#39;: {&#39;c&#39;: 1.0}, &#39;c&#39;: {&#39;a&#39;: 1.0}}</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="IdealFlow.Network.IFN.signature_to_ideal_flow">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">signature_to_ideal_flow</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">cycle_signature</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">is_cycle</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">dict</span></span></span><a class="headerlink" href="#IdealFlow.Network.IFN.signature_to_ideal_flow" title="Link to this definition"></a></dt>
<dd><p>Convert cycle signature to an ideal flow adjacency list.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>cycle_signature</strong> (<em>str</em>)  The cycle signature.</p></li>
<li><p><strong>is_cycle</strong> (<em>bool</em>)  Whether the signature represents a cycle.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The ideal flow adjacency list.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>dict</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">IdealFlow.Network</span> <span class="k">as</span> <span class="nn">net</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="n">net</span><span class="o">.</span><span class="n">IFN</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">signature_to_ideal_flow</span><span class="p">(</span><span class="s2">&quot;abc&quot;</span><span class="p">)</span>
<span class="go">{&#39;a&#39;: {&#39;b&#39;: 1.0}, &#39;b&#39;: {&#39;c&#39;: 1.0}, &#39;c&#39;: {&#39;a&#39;: 1.0}}</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="IdealFlow.Network.IFN.signature_to_kappa">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">signature_to_kappa</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">cycle_signature</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">float</span></span></span><a class="headerlink" href="#IdealFlow.Network.IFN.signature_to_kappa" title="Link to this definition"></a></dt>
<dd><p>Compute the kappa value of a cycle signature.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>cycle_signature</strong> (<em>str</em>)  The cycle signature.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The kappa value.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">IdealFlow.Network</span> <span class="k">as</span> <span class="nn">net</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="n">net</span><span class="o">.</span><span class="n">IFN</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">signature_to_kappa</span><span class="p">(</span><span class="s2">&quot;abc + def&quot;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="IdealFlow.Network.IFN.signature_to_link_flow">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">signature_to_link_flow</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">cycle_signature</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">is_cycle</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">dict</span></span></span><a class="headerlink" href="#IdealFlow.Network.IFN.signature_to_link_flow" title="Link to this definition"></a></dt>
<dd><p>Compute link flow values from a cycle signature.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>cycle_signature</strong> (<em>str</em>)  The cycle signature.</p></li>
<li><p><strong>is_cycle</strong> (<em>bool</em>)  Whether the signature represents a cycle.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The link flow values.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>dict</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">IdealFlow.Network</span> <span class="k">as</span> <span class="nn">net</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="n">net</span><span class="o">.</span><span class="n">IFN</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">signature</span> <span class="o">=</span> <span class="s2">&quot;abc + def&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">result</span> <span class="o">=</span> <span class="n">n</span><span class="o">.</span><span class="n">signature_to_link_flow</span><span class="p">(</span><span class="n">signature</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>  <span class="c1"># Output: {&#39;ab&#39;: 1, &#39;bc&#39;: 1, &#39;ca&#39;: 1, &#39;de&#39;: 1, &#39;ef&#39;: 1, &#39;fd&#39;: 1}</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="IdealFlow.Network.IFN.signature_to_links">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">signature_to_links</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">cycle_signature</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">is_cycle</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">set</span></span></span><a class="headerlink" href="#IdealFlow.Network.IFN.signature_to_links" title="Link to this definition"></a></dt>
<dd><p>Compute the links in a cycle signature.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>cycle_signature</strong> (<em>str</em>)  The cycle signature.</p></li>
<li><p><strong>is_cycle</strong> (<em>bool</em>)  Whether the signature represents a cycle.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A set of links.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>set</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">IdealFlow.Network</span> <span class="k">as</span> <span class="nn">net</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="n">net</span><span class="o">.</span><span class="n">IFN</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">signature</span> <span class="o">=</span> <span class="s2">&quot;abc + def&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">result</span> <span class="o">=</span> <span class="n">n</span><span class="o">.</span><span class="n">signature_to_links</span><span class="p">(</span><span class="n">signature</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>  <span class="c1"># Output: {&#39;ab&#39;, &#39;bc&#39;, &#39;ca&#39;, &#39;de&#39;, &#39;ef&#39;, &#39;fd&#39;}</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="IdealFlow.Network.IFN.signature_to_max_flow">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">signature_to_max_flow</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">cycle_signature</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">float</span></span></span><a class="headerlink" href="#IdealFlow.Network.IFN.signature_to_max_flow" title="Link to this definition"></a></dt>
<dd><p>Compute the maximum flow value in a cycle signature.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>cycle_signature</strong> (<em>str</em>)  The cycle signature.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The maximum flow value.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">IdealFlow.Network</span> <span class="k">as</span> <span class="nn">net</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="n">net</span><span class="o">.</span><span class="n">IFN</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">signature_to_max_flow</span><span class="p">(</span><span class="s2">&quot;abc + def&quot;</span><span class="p">)</span>
<span class="go">1.0</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="IdealFlow.Network.IFN.signature_to_min_flow">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">signature_to_min_flow</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">cycle_signature</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">float</span></span></span><a class="headerlink" href="#IdealFlow.Network.IFN.signature_to_min_flow" title="Link to this definition"></a></dt>
<dd><p>Compute the minimum flow value in a cycle signature.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>cycle_signature</strong> (<em>str</em>)  The cycle signature.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The minimum flow value.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">IdealFlow.Network</span> <span class="k">as</span> <span class="nn">net</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="n">net</span><span class="o">.</span><span class="n">IFN</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">signature_to_min_flow</span><span class="p">(</span><span class="s2">&quot;abc + def&quot;</span><span class="p">)</span>
<span class="go">1.0</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="IdealFlow.Network.IFN.signature_to_num_links">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">signature_to_num_links</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">cycle_signature</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">is_cycle</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">int</span></span></span><a class="headerlink" href="#IdealFlow.Network.IFN.signature_to_num_links" title="Link to this definition"></a></dt>
<dd><p>Compute the number of links in a cycle signature.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>cycle_signature</strong> (<em>str</em>)  The cycle signature.</p></li>
<li><p><strong>is_cycle</strong> (<em>bool</em>)  Whether the signature represents a cycle.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The number of links.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>int</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">IdealFlow.Network</span> <span class="k">as</span> <span class="nn">net</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="n">net</span><span class="o">.</span><span class="n">IFN</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">signature_to_num_links</span><span class="p">(</span><span class="s2">&quot;abc + def&quot;</span><span class="p">)</span>
<span class="go">4</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="IdealFlow.Network.IFN.signature_to_num_nodes">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">signature_to_num_nodes</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">cycle_signature</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">int</span></span></span><a class="headerlink" href="#IdealFlow.Network.IFN.signature_to_num_nodes" title="Link to this definition"></a></dt>
<dd><p>Compute the number of nodes in a cycle signature.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>cycle_signature</strong> (<em>str</em>)  The cycle signature.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The number of unique nodes.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>int</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">IdealFlow.Network</span> <span class="k">as</span> <span class="nn">net</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="n">net</span><span class="o">.</span><span class="n">IFN</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">signature</span> <span class="o">=</span> <span class="s2">&quot;abc + def&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">result</span> <span class="o">=</span> <span class="n">n</span><span class="o">.</span><span class="n">signature_to_num_nodes</span><span class="p">(</span><span class="n">signature</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>  <span class="c1"># Output: 6</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="IdealFlow.Network.IFN.signature_to_pivots">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">signature_to_pivots</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">cycle_signature</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">dict</span></span></span><a class="headerlink" href="#IdealFlow.Network.IFN.signature_to_pivots" title="Link to this definition"></a></dt>
<dd><p>Find pivots in a cycle signature.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>cycle_signature</strong> (<em>str</em>)  The cycle signature.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A dictionary of pivots between cycles.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>dict</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">IdealFlow.Network</span> <span class="k">as</span> <span class="nn">net</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="n">net</span><span class="o">.</span><span class="n">IFN</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">signature_to_pivots</span><span class="p">(</span><span class="s2">&quot;abc + abd&quot;</span><span class="p">)</span>
<span class="go">{&#39;abc-abd&#39;: [&#39;a&#39;, &#39;b&#39;]}</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="IdealFlow.Network.IFN.signature_to_row_stochastic">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">signature_to_row_stochastic</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">cycle_signature</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">is_cycle</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">dict</span></span></span><a class="headerlink" href="#IdealFlow.Network.IFN.signature_to_row_stochastic" title="Link to this definition"></a></dt>
<dd><p>Convert cycle signature to a row stochastic adjacency list.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>cycle_signature</strong> (<em>str</em>)  The cycle signature.</p></li>
<li><p><strong>is_cycle</strong> (<em>bool</em>)  Whether the signature represents a cycle.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The row stochastic adjacency list.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>dict</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">IdealFlow.Network</span> <span class="k">as</span> <span class="nn">net</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="n">net</span><span class="o">.</span><span class="n">IFN</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">signature_to_row_stochastic</span><span class="p">(</span><span class="s2">&quot;abc&quot;</span><span class="p">)</span>
<span class="go">{&#39;a&#39;: {&#39;b&#39;: 1.0}, &#39;b&#39;: {&#39;c&#39;: 1.0}, &#39;c&#39;: {&#39;a&#39;: 1.0}}</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="IdealFlow.Network.IFN.signature_to_sum_cols">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">signature_to_sum_cols</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">cycle_signature</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">dict</span></span></span><a class="headerlink" href="#IdealFlow.Network.IFN.signature_to_sum_cols" title="Link to this definition"></a></dt>
<dd><p>Compute the sum of columns in a cycle signature.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>cycle_signature</strong> (<em>str</em>)  The cycle signature.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A dictionary of column sums.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>dict</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">IdealFlow.Network</span> <span class="k">as</span> <span class="nn">net</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="n">net</span><span class="o">.</span><span class="n">IFN</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">signature_to_sum_cols</span><span class="p">(</span><span class="s2">&quot;abc + def&quot;</span><span class="p">)</span>
<span class="go">{&#39;a&#39;: 1, &#39;b&#39;: 1, &#39;c&#39;: 1, &#39;d&#39;: 1, &#39;e&#39;: 1, &#39;f&#39;: 1}</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="IdealFlow.Network.IFN.signature_to_sum_rows">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">signature_to_sum_rows</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">cycle_signature</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">dict</span></span></span><a class="headerlink" href="#IdealFlow.Network.IFN.signature_to_sum_rows" title="Link to this definition"></a></dt>
<dd><p>Compute the sum of rows in a cycle signature.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>cycle_signature</strong> (<em>str</em>)  The cycle signature.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A dictionary of row sums.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>dict</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">IdealFlow.Network</span> <span class="k">as</span> <span class="nn">net</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="n">net</span><span class="o">.</span><span class="n">IFN</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">signature_to_sum_rows</span><span class="p">(</span><span class="s2">&quot;abc + def&quot;</span><span class="p">)</span>
<span class="go">{&#39;a&#39;: 1, &#39;b&#39;: 1, &#39;c&#39;: 1, &#39;d&#39;: 1, &#39;e&#39;: 1, &#39;f&#39;: 1}</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="IdealFlow.Network.IFN.solve_cycles">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">solve_cycles</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">F</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">'lsq_linear'</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">str</span></span></span><a class="headerlink" href="#IdealFlow.Network.IFN.solve_cycles" title="Link to this definition"></a></dt>
<dd><p>Solves the cycle decomposition for a given flow matrix using one of three methods:
pinv, lsq_linear, or nnls.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>F</strong> (<em>np.ndarray</em>)  The flow matrix.</p></li>
<li><p><strong>method</strong> (<em>str</em><em>, </em><em>optional</em>)  The method to solve the system. Options are:
- pinv: Uses the generalized inverse solution (can produce negative results).
- lsq_linear: Uses least-squares with non-negativity constraints (default).
- nnls: Uses non-negative least squares.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A string representation of the decomposed cycles.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>str</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>ValueError</strong>  If an unsupported method is provided.</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">IdealFlow.Network</span> <span class="k">as</span> <span class="nn">net</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="n">net</span><span class="o">.</span><span class="n">IFN</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">F</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">solve_cycles</span><span class="p">(</span><span class="n">F</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;lsq_linear&#39;</span><span class="p">)</span>
<span class="go">&#39;ab + ba&#39;</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="IdealFlow.Network.IFN.stationary_markov_chain">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">stationary_markov_chain</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">S</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">list</span></span></span><a class="headerlink" href="#IdealFlow.Network.IFN.stationary_markov_chain" title="Link to this definition"></a></dt>
<dd><p>Compute the stationary distribution of a Markov chain.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>S</strong> (<em>list</em>)  The stochastic matrix.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The stationary distribution.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>list</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">IdealFlow.Network</span> <span class="k">as</span> <span class="nn">net</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">S</span> <span class="o">=</span> <span class="p">[[</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="n">net</span><span class="o">.</span><span class="n">IFN</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">stationary_dist</span> <span class="o">=</span> <span class="n">n</span><span class="o">.</span><span class="n">stationary_markov_chain</span><span class="p">(</span><span class="n">S</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">stationary_dist</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="IdealFlow.Network.IFN.stdev_flow">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">stdev_flow</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">float</span></em><a class="headerlink" href="#IdealFlow.Network.IFN.stdev_flow" title="Link to this definition"></a></dt>
<dd><p>Calculate the internal standard deviation of the flow across all links in the network.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The standard deviation of flow.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>float</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">IdealFlow.Network</span> <span class="k">as</span> <span class="nn">net</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">C</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="n">net</span><span class="o">.</span><span class="n">IFN</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">set_matrix</span><span class="p">(</span><span class="n">C</span><span class="p">,[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span><span class="s1">&#39;b&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">stdev_flow</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="IdealFlow.Network.IFN.stdev_flow_matrix">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">stdev_flow_matrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">F</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">float</span></span></span><a class="headerlink" href="#IdealFlow.Network.IFN.stdev_flow_matrix" title="Link to this definition"></a></dt>
<dd><p>Compute the standard deviation of flow values in a flow matrix.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>F</strong> (<em>list</em>)  The flow matrix.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The standard deviation of flow values.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">IdealFlow.Network</span> <span class="k">as</span> <span class="nn">net</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">F</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="n">net</span><span class="o">.</span><span class="n">IFN</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">std_flow_value</span> <span class="o">=</span> <span class="n">n</span><span class="o">.</span><span class="n">stdev_flow_matrix</span><span class="p">(</span><span class="n">F</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">std_flow_value</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="IdealFlow.Network.IFN.stochastic_to_entropy_ratio">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">stochastic_to_entropy_ratio</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">S</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">float</span></span></span><a class="headerlink" href="#IdealFlow.Network.IFN.stochastic_to_entropy_ratio" title="Link to this definition"></a></dt>
<dd><p>Compute entropy ratio from stochastic matrix.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>S</strong> (<em>list</em>)  The stochastic matrix.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The entropy ratio.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">IdealFlow.Network</span> <span class="k">as</span> <span class="nn">net</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">S</span> <span class="o">=</span> <span class="p">[[</span><span class="mf">0.4</span><span class="p">,</span> <span class="mf">0.6</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.7</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="n">net</span><span class="o">.</span><span class="n">IFN</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ratio</span> <span class="o">=</span> <span class="n">n</span><span class="o">.</span><span class="n">stochastic_to_entropy_ratio</span><span class="p">(</span><span class="n">S</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">ratio</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="IdealFlow.Network.IFN.stochastic_to_ideal_flow">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">stochastic_to_ideal_flow</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">S</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kappa</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">list</span></span></span><a class="headerlink" href="#IdealFlow.Network.IFN.stochastic_to_ideal_flow" title="Link to this definition"></a></dt>
<dd><p>Convert stochastic matrix to ideal flow matrix.
If matrix size is les than 25, use exact method else, use approximate method which is fast but inaccurate.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>S</strong> (<em>list</em>)  The stochastic matrix.</p></li>
<li><p><strong>kappa</strong> (<em>float</em>)  The kappa parameter.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The ideal flow matrix.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>list</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">IdealFlow.Network</span> <span class="k">as</span> <span class="nn">net</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">S</span> <span class="o">=</span> <span class="p">[[</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="n">net</span><span class="o">.</span><span class="n">IFN</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ideal_flow</span> <span class="o">=</span> <span class="n">n</span><span class="o">.</span><span class="n">stochastic_to_ideal_flow</span><span class="p">(</span><span class="n">S</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">ideal_flow</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="IdealFlow.Network.IFN.stochastic_to_network_entropy">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">stochastic_to_network_entropy</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">S</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">float</span></span></span><a class="headerlink" href="#IdealFlow.Network.IFN.stochastic_to_network_entropy" title="Link to this definition"></a></dt>
<dd><p>Compute network entropy from stochastic matrix.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>S</strong> (<em>list</em>)  The stochastic matrix.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The network entropy.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">IdealFlow.Network</span> <span class="k">as</span> <span class="nn">net</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">S</span> <span class="o">=</span> <span class="p">[[</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="n">net</span><span class="o">.</span><span class="n">IFN</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">entropy</span> <span class="o">=</span> <span class="n">n</span><span class="o">.</span><span class="n">stochastic_to_network_entropy</span><span class="p">(</span><span class="n">S</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">entropy</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="IdealFlow.Network.IFN.stochastic_to_pi">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">stochastic_to_pi</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">S</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kappa</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">list</span></span></span><a class="headerlink" href="#IdealFlow.Network.IFN.stochastic_to_pi" title="Link to this definition"></a></dt>
<dd><p>Compute Perron vector (phi) from stochastic matrix.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>S</strong> (<em>list</em>)  The stochastic matrix.</p></li>
<li><p><strong>kappa</strong> (<em>float</em>)  The kappa parameter.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The Perron vector.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>list</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">IdealFlow.Network</span> <span class="k">as</span> <span class="nn">net</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">S</span> <span class="o">=</span> <span class="p">[[</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="n">net</span><span class="o">.</span><span class="n">IFN</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pi</span> <span class="o">=</span> <span class="n">n</span><span class="o">.</span><span class="n">stochastic_to_pi</span><span class="p">(</span><span class="n">S</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">pi</span><span class="p">)</span>
</pre></div>
</div>
<dl class="simple">
<dt>Alias:</dt><dd><p><a class="reference internal" href="#IdealFlow.Network.IFN.markov" title="IdealFlow.Network.IFN.markov"><code class="xref py py-meth docutils literal notranslate"><span class="pre">markov()</span></code></a></p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#IdealFlow.Network.IFN.stationary_markov_chain" title="IdealFlow.Network.IFN.stationary_markov_chain"><code class="xref py py-meth docutils literal notranslate"><span class="pre">stationary_markov_chain()</span></code></a></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="IdealFlow.Network.IFN.stochastic_to_probability">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">stochastic_to_probability</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">S</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">list</span></span></span><a class="headerlink" href="#IdealFlow.Network.IFN.stochastic_to_probability" title="Link to this definition"></a></dt>
<dd><p>Compute probability matrix from stochastic matrix.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>S</strong> (<em>list</em>)  The stochastic matrix.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The probability matrix.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>list</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">IdealFlow.Network</span> <span class="k">as</span> <span class="nn">net</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">S</span> <span class="o">=</span> <span class="p">[[</span><span class="mf">0.3</span><span class="p">,</span> <span class="mf">0.7</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.6</span><span class="p">,</span> <span class="mf">0.4</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="n">net</span><span class="o">.</span><span class="n">IFN</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">prob_matrix</span> <span class="o">=</span> <span class="n">n</span><span class="o">.</span><span class="n">stochastic_to_probability</span><span class="p">(</span><span class="n">S</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">prob_matrix</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="IdealFlow.Network.IFN.str_to_num">
<span class="sig-name descname"><span class="pre">str_to_num</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#IdealFlow.Network.IFN.str_to_num" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="IdealFlow.Network.IFN.string_to_matrix">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">string_to_matrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">signature</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">ndarray</span></span></span><a class="headerlink" href="#IdealFlow.Network.IFN.string_to_matrix" title="Link to this definition"></a></dt>
<dd><p>Converts a cycle string into a flow matrix.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>signature</strong> (<em>str</em>)  The cycle string representation.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The flow matrix.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>np.ndarray</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#IdealFlow.Network.IFN.compose" title="IdealFlow.Network.IFN.compose"><code class="xref py py-meth docutils literal notranslate"><span class="pre">compose()</span></code></a></p>
</div>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">IdealFlow.Network</span> <span class="k">as</span> <span class="nn">net</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="n">net</span><span class="o">.</span><span class="n">IFN</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">F</span> <span class="o">=</span> <span class="n">n</span><span class="o">.</span><span class="n">string_to_matrix</span><span class="p">(</span><span class="s1">&#39;a+b+c&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">F</span>
<span class="go">array([[1, 0, 0],</span>
<span class="go">       [0, 1, 0],</span>
<span class="go">       [0, 0, 1]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">F</span> <span class="o">=</span> <span class="n">n</span><span class="o">.</span><span class="n">string_to_matrix</span><span class="p">(</span><span class="s1">&#39;ab+ba+cab&#39;</span><span class="p">)</span>
<span class="go">array([[0, 3, 0],</span>
<span class="go">       [2, 0, 1],</span>
<span class="go">       [1, 0, 0]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="IdealFlow.Network.IFN.sum_dict_values">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">sum_dict_values</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dic</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">dict</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">float</span></span></span><a class="headerlink" href="#IdealFlow.Network.IFN.sum_dict_values" title="Link to this definition"></a></dt>
<dd><p>Sum the values of a dictionary, treating <cite>None</cite> as zero.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>dic</strong> (<em>dict</em>)  The dictionary with values to sum.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The sum of the dictionarys values.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">IdealFlow.Network</span> <span class="k">as</span> <span class="nn">net</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="n">net</span><span class="o">.</span><span class="n">IFN</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;a&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">sum_dict_values</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
<span class="go">4.0</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="IdealFlow.Network.IFN.sum_of_col">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">sum_of_col</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">M</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">list</span></span></span><a class="headerlink" href="#IdealFlow.Network.IFN.sum_of_col" title="Link to this definition"></a></dt>
<dd><p>Compute the sum of each column in a matrix.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>M</strong> (<em>list</em>)  The input matrix.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The column sums.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>list</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">IdealFlow.Network</span> <span class="k">as</span> <span class="nn">net</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="n">net</span><span class="o">.</span><span class="n">IFN</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">col_sums</span> <span class="o">=</span> <span class="n">n</span><span class="o">.</span><span class="n">sum_of_col</span><span class="p">(</span><span class="n">M</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">col_sums</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="IdealFlow.Network.IFN.sum_of_row">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">sum_of_row</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">M</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">list</span></span></span><a class="headerlink" href="#IdealFlow.Network.IFN.sum_of_row" title="Link to this definition"></a></dt>
<dd><p>Compute the sum of each row in a matrix.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>M</strong> (<em>list</em>)  The input matrix.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The row sums.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>list</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">IdealFlow.Network</span> <span class="k">as</span> <span class="nn">net</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="n">net</span><span class="o">.</span><span class="n">IFN</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">row_sums</span> <span class="o">=</span> <span class="n">n</span><span class="o">.</span><span class="n">sum_of_row</span><span class="p">(</span><span class="n">M</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">row_sums</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="IdealFlow.Network.IFN.to_adjacency_matrix">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">to_adjacency_matrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">matrix</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#IdealFlow.Network.IFN.to_adjacency_matrix" title="Link to this definition"></a></dt>
<dd><p>Convert a non-negative matrix to a binary (0, 1) adjacency matrix.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>matrix</strong> (<em>list</em><em> of </em><em>list</em><em> of </em><em>int/float</em>)  The input matrix.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The adjacency matrix.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>np.array</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">IdealFlow.Network</span> <span class="k">as</span> <span class="nn">net</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="n">net</span><span class="o">.</span><span class="n">IFN</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">matrix</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">to_adjacency_matrix</span><span class="p">(</span><span class="n">matrix</span><span class="p">)</span>
<span class="go">array([[0, 1], [1, 0]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="IdealFlow.Network.IFN.to_base62">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">to_base62</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">num</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">str</span></span></span><a class="headerlink" href="#IdealFlow.Network.IFN.to_base62" title="Link to this definition"></a></dt>
<dd><p>Convert a integer number to a base62 string.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>num</strong> (<em>int</em>)  The number to convert.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The base62 string.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>str</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>ValueError</strong>  If the number is negative.</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">IdealFlow.Network</span> <span class="k">as</span> <span class="nn">net</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="n">net</span><span class="o">.</span><span class="n">IFN</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">to_base62</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="go">&#39;0&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">to_base62</span><span class="p">(</span><span class="mi">36</span><span class="p">)</span>
<span class="go">&#39;A&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">to_base62</span><span class="p">(</span><span class="mi">123</span><span class="p">)</span>
<span class="go">&#39;1Z&#39;</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="IdealFlow.Network.IFN.to_equal_inflow">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">to_equal_inflow</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">C</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#IdealFlow.Network.IFN.to_equal_inflow" title="Link to this definition"></a></dt>
<dd><p>Return ideal flow matrix with equal inflow from capacity matrix.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>C</strong> (<em>list</em><em> of </em><em>list</em><em> of </em><em>int/float</em>)  The capacity matrix.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The ideal flow matrix.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>list of list of int/float</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">IdealFlow.Network</span> <span class="k">as</span> <span class="nn">net</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="n">net</span><span class="o">.</span><span class="n">IFN</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">C</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">to_equal_inflow</span><span class="p">(</span><span class="n">C</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="IdealFlow.Network.IFN.to_equal_outflow">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">to_equal_outflow</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">C</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#IdealFlow.Network.IFN.to_equal_outflow" title="Link to this definition"></a></dt>
<dd><p>Return ideal flow matrix with equal outflow from capacity matrix.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>C</strong> (<em>list</em><em> of </em><em>list</em><em> of </em><em>int/float</em>)  The capacity matrix.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The ideal flow matrix.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>list of list of int/float</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">IdealFlow.Network</span> <span class="k">as</span> <span class="nn">net</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="n">net</span><span class="o">.</span><span class="n">IFN</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">C</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">to_equal_outflow</span><span class="p">(</span><span class="n">C</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="IdealFlow.Network.IFN.to_graph">
<span class="sig-name descname"><span class="pre">to_graph</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#IdealFlow.Network.IFN" title="IdealFlow.Network.IFN"><span class="pre">IFN</span></a></span></span><a class="headerlink" href="#IdealFlow.Network.IFN.to_graph" title="Link to this definition"></a></dt>
<dd><p>Convert the digraph to a graph, making the adjacency matrix symmetric.
The link weights are adjusted to all 1.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>A new network representing the graph counterpart of the digraph.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference internal" href="#IdealFlow.Network.IFN" title="IdealFlow.Network.IFN">IFN</a></p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">IdealFlow.Network</span> <span class="k">as</span> <span class="nn">net</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="n">net</span><span class="o">.</span><span class="n">IFN</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">graph_net</span> <span class="o">=</span> <span class="n">n</span><span class="o">.</span><span class="n">to_graph</span><span class="p">()</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="IdealFlow.Network.IFN.to_markov_order">
<span class="sig-name descname"><span class="pre">to_markov_order</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">trajectory</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">toOrder</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">list</span></span></span><a class="headerlink" href="#IdealFlow.Network.IFN.to_markov_order" title="Link to this definition"></a></dt>
<dd><p>Convert a trajectory from any Markov order to a specified Markov order.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>trajectory</strong> (<em>list</em>)  A list of nodes representing the trajectory.</p></li>
<li><p><strong>toOrder</strong> (<em>int</em>)  The desired Markov order.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A list representing the trajectory in the specified Markov order.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>list</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">IdealFlow.Network</span> <span class="k">as</span> <span class="nn">net</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="n">net</span><span class="o">.</span><span class="n">IFN</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">to_markov_order</span><span class="p">([</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">],</span> <span class="mi">2</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="IdealFlow.Network.IFN.total_flow">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">total_flow</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">float</span></em><a class="headerlink" href="#IdealFlow.Network.IFN.total_flow" title="Link to this definition"></a></dt>
<dd><p>Calculate the total flow in the network, which is the sum of all edge weights.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The total flow in the network.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>float</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">IdealFlow.Network</span> <span class="k">as</span> <span class="nn">net</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="n">net</span><span class="o">.</span><span class="n">IFN</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">add_link</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">add_link</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">total_flow</span>
<span class="go">5</span>
</pre></div>
</div>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="IdealFlow.Network.IFN.total_links">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">total_links</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">int</span></em><a class="headerlink" href="#IdealFlow.Network.IFN.total_links" title="Link to this definition"></a></dt>
<dd><p>Returns the total number of links in the network.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The total number of links.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>int</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">IdealFlow.Network</span> <span class="k">as</span> <span class="nn">net</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="n">net</span><span class="o">.</span><span class="n">IFN</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">add_link</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">add_link</span><span class="p">(</span><span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">total_links</span><span class="p">)</span>
<span class="go">2</span>
</pre></div>
</div>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="IdealFlow.Network.IFN.total_nodes">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">total_nodes</span></span><a class="headerlink" href="#IdealFlow.Network.IFN.total_nodes" title="Link to this definition"></a></dt>
<dd><p>roperty to returns the total number of nodes in the network.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The total number of nodes.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>int</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">IdealFlow.Network</span> <span class="k">as</span> <span class="nn">net</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="n">net</span><span class="o">.</span><span class="n">IFN</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">add_link</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span><span class="s1">&#39;b&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">total_nodes</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="IdealFlow.Network.IFN.trajectory_to_links">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">trajectory_to_links</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">trajectory</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">list</span></span></span><a class="headerlink" href="#IdealFlow.Network.IFN.trajectory_to_links" title="Link to this definition"></a></dt>
<dd><p>Given a list of nodes, generate a list of links (node pairs).
Note: The trajectory is not necessarily a path in the network.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>trajectory</strong> (<em>list</em>)  A list of nodes.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A list of links (node pairs).</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>list</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">IdealFlow.Network</span> <span class="k">as</span> <span class="nn">net</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="n">net</span><span class="o">.</span><span class="n">IFN</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">trajectory_to_links</span><span class="p">([</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">])</span>
<span class="go">[[&#39;a&#39;, &#39;b&#39;], [&#39;b&#39;, &#39;c&#39;]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">trajectory_to_links</span><span class="p">([</span><span class="s1">&#39;a&#39;</span><span class="p">,</span><span class="s1">&#39;b&#39;</span><span class="p">,</span><span class="s1">&#39;c&#39;</span><span class="p">,</span><span class="s1">&#39;d&#39;</span><span class="p">])</span>
<span class="go"> [[&#39;a&#39;,&#39;b&#39;],[&#39;b&#39;,&#39;c&#39;],[&#39;c&#39;,&#39;d&#39;]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="IdealFlow.Network.IFN.union">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">union</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">net1</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#IdealFlow.Network.IFN" title="IdealFlow.Network.IFN"><span class="pre">IFN</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">net2</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#IdealFlow.Network.IFN" title="IdealFlow.Network.IFN"><span class="pre">IFN</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#IdealFlow.Network.IFN" title="IdealFlow.Network.IFN"><span class="pre">IFN</span></a></span></span><a class="headerlink" href="#IdealFlow.Network.IFN.union" title="Link to this definition"></a></dt>
<dd><p>Return the union of two networks, combining links and nodes from both.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>net1</strong> (<a class="reference internal" href="#IdealFlow.Network.IFN" title="IdealFlow.Network.IFN"><em>IFN</em></a>)  The first network.</p></li>
<li><p><strong>net2</strong> (<a class="reference internal" href="#IdealFlow.Network.IFN" title="IdealFlow.Network.IFN"><em>IFN</em></a>)  The second network.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A new network containing the union of net1 and net2.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="#IdealFlow.Network.IFN" title="IdealFlow.Network.IFN">IFN</a></p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">IdealFlow.Network</span> <span class="k">as</span> <span class="nn">net</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="n">net</span><span class="o">.</span><span class="n">IFN</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">net1</span><span class="p">,</span> <span class="n">net2</span> <span class="o">=</span> <span class="n">net</span><span class="o">.</span><span class="n">IFN</span><span class="p">(),</span> <span class="n">net</span><span class="o">.</span><span class="n">IFN</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">union_net</span> <span class="o">=</span> <span class="n">n</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="n">net1</span><span class="p">,</span> <span class="n">net2</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="IdealFlow.Network.IFN.universe">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">universe</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">net</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#IdealFlow.Network.IFN" title="IdealFlow.Network.IFN"><span class="pre">IFN</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#IdealFlow.Network.IFN" title="IdealFlow.Network.IFN"><span class="pre">IFN</span></a></span></span><a class="headerlink" href="#IdealFlow.Network.IFN.universe" title="Link to this definition"></a></dt>
<dd><p>Return the universe (complete digraph) of the given network.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>net</strong> (<a class="reference internal" href="#IdealFlow.Network.IFN" title="IdealFlow.Network.IFN"><em>IFN</em></a>)  The network to create a universe from.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A complete graph representing the universe of the network.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="#IdealFlow.Network.IFN" title="IdealFlow.Network.IFN">IFN</a></p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">IdealFlow.Network</span> <span class="k">as</span> <span class="nn">net</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="n">net</span><span class="o">.</span><span class="n">IFN</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">universe_net</span> <span class="o">=</span> <span class="n">n</span><span class="o">.</span><span class="n">universe</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="IdealFlow.Network.IFN.unlearn">
<span class="sig-name descname"><span class="pre">unlearn</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">trajectory</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#IdealFlow.Network.IFN.unlearn" title="Link to this definition"></a></dt>
<dd><p>Unassign (subtract weight) a trajectory from the network by setting weight = -1 for each link along the trajectory.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>trajectory</strong> (<em>list</em>)  A list of nodes representing the trajectory (node sequence) to be unlearned.</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">IdealFlow.Network</span> <span class="k">as</span> <span class="nn">net</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="n">net</span><span class="o">.</span><span class="n">IFN</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">add_link</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">add_link</span><span class="p">(</span><span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">unlearn</span><span class="p">([</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="IdealFlow.Network.IFN.weighted_random_choice">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">weighted_random_choice</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">list_nodes</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">probs</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">str</span></span></span><a class="headerlink" href="#IdealFlow.Network.IFN.weighted_random_choice" title="Link to this definition"></a></dt>
<dd><p>Select a random node from a list based on given probabilities.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>list_nodes</strong> (<em>list</em><em> of </em><em>str</em>)  List of node names.</p></li>
<li><p><strong>probs</strong> (<em>list</em><em> of </em><em>float</em>)  List of probabilities corresponding to each node.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Selected node.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>str</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">IdealFlow.Network</span> <span class="k">as</span> <span class="nn">net</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="n">net</span><span class="o">.</span><span class="n">IFN</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">nodes</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;B&#39;</span><span class="p">,</span> <span class="s1">&#39;C&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">probabilities</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">result</span> <span class="o">=</span> <span class="n">n</span><span class="o">.</span><span class="n">weighted_random_choice</span><span class="p">(</span><span class="n">nodes</span><span class="p">,</span> <span class="n">probabilities</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
<span class="go">&#39;B&#39;</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="unit_tests.html" class="btn btn-neutral float-left" title="Unit Tests" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="modules.html" class="btn btn-neutral float-right" title="IdealFlow" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2024, Kardi Teknomo.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>